void generateMainHeader( P: program )
{
	Output = new parser<out_c::out_c>()
	Thread: thread = ThreadMap->find( 'Main' )

	send Output
		~/*
		~ * main_gen.h
		~ */
		~
		~#ifndef _MAIN_GEN_H
		~#define _MAIN_GEN_H
		~
		~#include <genf/thread.h>
		~#include "itq_gen.h"
		~#include "packet_gen.h"
		~

	threadForwards( Thread )

	send Output
		~struct MainGen
		~	: public Thread
		~{
		~	MainGen() : Thread("main") {}
		~
		~	void init( int argc, char *const*argv )
		~	{
		~		this->argc = argc;
		~		this->argv = argv;
		~	}
		~
		~	int argc;
		~	char *const*argv;
		~
		~	void parseOptions();
		~	void maybeBackground();
		~	int start();
		~	void join();
		~	virtual int main() { return 0; }
		~	virtual int poll() { return 0; }
		~
		~	virtual void data( SelectFd *fd );
		~	void close( SelectFd *fd );
		~
		~	void handleSignal( int sig );
		~	void signalSetup();
		~	int signalLoop( struct timeval *timer = 0 );
		~	int selectLoop( timeval *timer = 0, bool wantPoll = true );

	createChildDecls( Thread )
	sendsToDecls( Thread )
	optDefine( P )
	packetRecvDecls( Thread )

	send Output
		~};
		~
		~#endif

	send Output [] eos
	writeOutput( Output->tree, 'main_gen.h' )
}

void optString( P: program )
{
	send Output
		"const char optstring\[\] = \":"

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`- short]

			send Output [OS.short]
			if !match OD.option_type [`bool]
				send Output ":"
		}
	}

	send Output
		"\";
		"
}

void longOpts( P: ref<program> )
{
	send Output
		"const option longopts\[\] = {

	Ind: int = 0
	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`-- long]
			send Output
				"	{ \"[OS.long]\", "

			if match OD.option_type [`bool]
				send Output "no_argument"
			else
				send Output "required_argument"

			send Output
				", 0, 0 },

			# Save the index.
			OS.Ind = Ind
			Ind = Ind + 1
		}
	}

	send Output
		"	{ 0, 0, 0, 0 }
		"};
		"
}

void optDefine( P: program )
{
	Ind: int = 0
	for OD: option_def in P {
		switch OD.option_type
		case [`bool] {
			send Output
				"static bool [OD.id];
		}
		case [`string] {
			send Output
				"static std::string [OD.id];

		}
		case [`long] {
			send Output
				"static long [OD.id];
		}
	}

	send Output "
}

void optDeclare( P: program )
{
	Ind: int = 0
	for OD: option_def in P {
		switch OD.option_type
		case [`bool] {
			send Output
				"bool MainGen::[OD.id] = false;
		}
		case [`string] {
			send Output
				"std::string MainGen::[OD.id] = \"\";

		}
		case [`long] {
			send Output
				"long MainGen::[OD.id] = 0;
		}
	}

	send Output "
}

void parseOption( OD: option_def, Src: str )
{
	switch OD.option_type
	case [`bool] {
		send Output
			"[OD.id] = true;
	}
	case [`string] {
		send Output
			"[OD.id] = [Src];

	}
	case [`long] {
		send Output
			"char *eptr;
			"if ( *[Src] == 0 )
			"	log_FATAL( \"no characters found in [OD.id] (long) value\" );
			"
			"[OD.id] = strtol( [Src], &eptr, 10 );
			"
			"if ( *eptr != 0 )
			"	log_FATAL( \"invalid characters in [OD.id] (long) value: \" << [Src] );
			"if ( ( [OD.id] == LONG_MAX || [OD.id] == LONG_MIN) && errno == ERANGE )
			"	log_FATAL( \"[OD.id] (long) out of range: \" << [Src] );
			"if ( [OD.id] == 0 && errno != 0 )
			"	log_FATAL( \"failed to parse [OD.id] (long): \" << [Src] );
	}	
}

void parseOptions( P: ref<program> )
{
	send Output
		"void MainGen::parseOptions()
		"{
		"	while ( true ) {
		"		int option_index = 0;
		"		int c = getopt_long( argc, argv, optstring, longopts, &option_index );
		"		if ( c == -1 )
		"			break;
		"		switch ( c ) {

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`- short]

			send Output
				"			case '[OS.short]': {
				"				[parseOption( OD, 'optarg' )]
				"				break;
				"			}
		}
	}
	
	send Output
		"			case 0: {
		"				switch ( option_index ) {

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`-- long]
			send Output
				"				case [OS.Ind]:
				"					[parseOption( OD, '(argv[optind-1])' )]
				"					break;
		}
	}

	send Output
		"				}
		"				break;
		"			}
		"			case ':': 
		"			case '?': {
		"				const char *msg = ( c == '?' ) ? 
		"						\"unknown option: \" :
		"						\"missing argument for option: \";
		"
		"				if ( optopt == 0 )
		"					log_FATAL( msg << argv\[optind-1\] );
		"				else 
		"					log_FATAL( msg << \"-\" << (char)optopt );
		"				break;
		"			}
		"		}
		"	}
		"}
}

void generateMainCode( P: ref<program> )
{
	Output = new parser<out_c::out_c>()
	Thread: thread = ThreadMap->find( 'Main' )

	send Output
		~/*
		~ * main_gen.cc
		~ */
		~

	send Output
		~#include <iostream>
		~#include <unistd.h>
		~#include <getopt.h>
		~#include <errno.h>
		~#include <stdlib.h>
		~#include <limits.h>
		~#include <string.h>
		~#include <signal.h>
		~#include <sys/time.h>
		~
		~#include "main.h"

	threadIncludes( Thread )
	send Output ~
	
	optString( P )
	longOpts( P )
	optDeclare( P )
	parseOptions( P )

	send Output
		~void MainGen::maybeBackground()
		~{
		~	if ( background ) {
		~		int result = daemon( 0, 0 );
		~		if ( result == -1 )
		~			log_FATAL( "damonize: " << strerror(errno) );
		~	}
		~}

	createChildDefs( Thread )

	send Output
		~int MainGen::start()
		~{
		~	parseOptions();
		~	if ( debugEnabled )
		~		enabledRealms = 0xffffffff;
		~	maybeBackground();
		~	signalSetup();
		~	return main();
		~}
		~

	#
	# Signal setup.
	#
	# Set a null sigusr handler for all threads to use. We use sigusr to break
	# from system calls and don't need to take action in the handler.
	#
	# Also mask the signals we wish to funnel to the main thread. All threads
	# will inherit this signal mask. The main thread uses an atomic unmask to
	# receive the sigs in the various loops it supports.
	#
	send Output
		~static void sigusrHandler( int s )
		~{
		~}
		~
		~
		~void MainGen::signalSetup()
		~{
		~	signal( SIGUSR1, sigusrHandler );
		~	signal( SIGUSR2, sigusrHandler );
		~
		~	sigset_t set;
		~	sigemptyset( &set );
		~
		~	funnelSigs( &set );
		~
		~	sigaddset( &set, SIGUSR1 );
		~	sigaddset( &set, SIGUSR2 );
		~
		~	pthread_sigmask( SIG_SETMASK, &set, 0 );
		~}
		~

	send Output
		~void MainGen::handleSignal( int sig )
		~{
		~	switch ( sig ) {
		~	case SIGHUP:
		~	{
		~		log_message( "received SIGHUP" );
		~		break;
		~	}
		~	case SIGINT:
		~	case SIGQUIT:
		~	case SIGKILL:
		~	case SIGTERM:
		~	{
		~		log_message( "breaking from signal loop" );
		~		breakLoop();
		~		break;
		~	}
		~	case SIGCHLD:
		~		/* Be quiet on a sigchld. */
		~		break;
		~	default: {
		~		log_message( "received sig: " << sig );
		~		break;
		~	}}
		~}
		~
		~int MainGen::signalLoop( struct timeval *timer )
		~{
		~	sigset_t set;
		~	sigfillset( &set );
		~
		~	sigemptyset( &set );
		~	funnelSigs( &set );
		~	sigaddset( &set, SIGUSR1 );
		~	sigaddset( &set, SIGUSR2 );
		~	pthread_sigmask( SIG_SETMASK, &set, 0 );
		~
		~	return Thread::signalLoop( &set, timer );
		~}
		~

	send Output
		~int MainGen::selectLoop( timeval *timer, bool wantPoll )
		~{
		~	sigset_t set;
		~	sigemptyset( &set );
		~
		~	signal( SIGHUP,  thread_funnel_handler );
		~	signal( SIGINT,  thread_funnel_handler );
		~	signal( SIGQUIT, thread_funnel_handler );
		~	signal( SIGKILL, thread_funnel_handler );
		~	signal( SIGTERM, thread_funnel_handler );
		~	signal( SIGCHLD, thread_funnel_handler );
		~
		~	return pselectLoop( &set, timer, wantPoll );
		~}

	joinDef( Thread )
	sendsToCode( Thread )
	packetReceives( Thread )

	send Output
		~Thread *getThis();
		~
		~int main( int argc, char *const*argv )
		~{
		~	pthread_key_create( &Thread::thisKey, 0 );
		~	genf::lf = new lfdostream( 2 );
		~	MainThread main;
		~	main.initId();
		~	main.init( argc, argv );
		~	return main.start();
		~}
		~

	send Output [] eos
	writeOutput( Output->tree, 'main_gen.cc' )
}
