void generateMainHeader( P: program )
{
	Output = cons parser<out_c::out_c>[]
	Thread: ptr<thread> = ThreadMap.find( 'Main' )

	send Output
		~/*
		~ * main_gen.h
		~ */
		~
		~#include "thread.h"
		~

	childDecls( Thread )

	send Output
		~struct MainGen
		~	: public Thread
		~{
		~	void init( int argc, char *const*argv )
		~	{
		~		this->argc = argc;
		~		this->argv = argv;
		~	}
		~
		~	int argc;
		~	char *const*argv;
		~
		~	void parseOptions();
		~	void maybeBackground();
		~	int start();
		~	virtual int main() { return 0; }

	registerChildDecls( Thread )

	send Output
		~};

	send Output [] eos
	writeOutput( Output.tree 'main_gen.h' )
}

void optString( P: program )
{
	send Output
		"const char optstring\[\] = \":"

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`- short]

			send Output [OS.short]
			if !match OD.option_type [`bool]
				send Output ":"
		}
	}

	send Output
		"\";
		"
}

void longOpts( P: ref<program> )
{
	send Output
		"const option longopts\[\] = {

	Ind: int = 0
	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`-- long]
			send Output
				"	{ \"[OS.long]\", "

			if match OD.option_type [`bool]
				send Output "no_argument"
			else
				send Output "required_argument"

			send Output
				", 0, 0 },

			# Save the index.
			OS.Ind = Ind
			Ind = Ind + 1
		}
	}

	send Output
		"	{ 0, 0, 0, 0 }
		"};
		"
}

void optValues( P: program )
{
	Ind: int = 0
	for OD: option_def in P {
		switch OD.option_type
		case [`bool] {
			send Output
				"bool [OD.id] = false;
		}
		case [`string] {
			send Output
				"std::string [OD.id];

		}
		case [`long] {
			send Output
				"long [OD.id];
		}
	}

	send Output "
}

void parseOption( OD: option_def Src: str )
{
	switch OD.option_type
	case [`bool] {
		send Output
			"[OD.id] = true;
	}
	case [`string] {
		send Output
			"[OD.id] = [Src];

	}
	case [`long] {
		send Output
			"char *eptr;
			"if ( *[Src] == 0 )
			"	log_FATAL( \"no characters found in [OD.id] (long) value\" );
			"
			"[OD.id] = strtol( [Src], &eptr, 10 );
			"
			"if ( *eptr != 0 )
			"	log_FATAL( \"invalid characters in [OD.id] (long) value: \" << [Src] );
			"if ( ( [OD.id] == LONG_MAX || [OD.id] == LONG_MIN) && errno == ERANGE )
			"	log_FATAL( \"[OD.id] (long) out of range: \" << [Src] );
			"if ( [OD.id] == 0 && errno != 0 )
			"	log_FATAL( \"failed to parse [OD.id] (long): \" << [Src] );
	}	
}

void parseOptions( P: ref<program> )
{
	send Output
		"void MainGen::parseOptions()
		"{
		"	while ( true ) {
		"		int option_index = 0;
		"		int c = getopt_long( argc, argv, optstring, longopts, &option_index );
		"		if ( c == -1 )
		"			break;
		"		switch ( c ) {

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`- short]

			send Output
				"			case '[OS.short]': {
				"				[parseOption( OD 'optarg' )]
				"				break;
				"			}
		}
	}
	
	send Output
		"			case 0: {
		"				switch ( option_index ) {

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`-- long]
			send Output
				"				case [OS.Ind]:
				"					[parseOption( OD '(argv[optind-1])' )]
				"					break;
		}
	}

	send Output
		"				}
		"				break;
		"			}
		"			case ':': 
		"			case '?': {
		"				const char *msg = ( c == '?' ) ? 
		"						\"unknown option: \" :
		"						\"missing argument for option: \";
		"
		"				if ( optopt == 0 )
		"					log_FATAL( msg << argv\[optind-1\] );
		"				else 
		"					log_FATAL( msg << \"-\" << (char)optopt );
		"				break;
		"			}
		"		}
		"	}
		"}
}

void generateMainCode( P: ref<program> )
{
	Output = cons parser<out_c::out_c>[]
	Thread: ptr<thread> = ThreadMap.find( 'Main' )

	send Output
		~/*
		~ * main_gen.cc
		~ */
		~

	send Output
		~#include <iostream>
		~#include <unistd.h>
		~#include <getopt.h>
		~#include <errno.h>
		~#include <stdlib.h>
		~#include <limits.h>
		~#include <string.h>
		~
		~#include "main.h"

	childIncludes( Thread )
	send Output ~
	
	optString( P )
	longOpts( P )
	optValues( P )
	parseOptions( P )

	send Output
		~void MainGen::maybeBackground()
		~{
		~	if ( background ) {
		~		int result = daemon( 0, 0 );
		~		if ( result == -1 )
		~			log_FATAL( "damonize: " << strerror(errno) );
		~	}
		~}

	registerChildDefs( Thread )

	send Output
		~int MainGen::start()
		~{
		~	parseOptions();
		~	maybeBackground();
		~	return main();
		~}

	send Output
		"int main( int argc, char *const*argv )
		"{
		"	MainThread main;
		"	main.init( argc, argv );
		"	return main.start();
		"}

	send Output [] eos
	writeOutput( Output.tree 'main_gen.cc' )
}
