void generateMainHeader( P: program )
{
	Output = new parser<out_c::out_c>()
	Thread: thread = ThreadMap->find( 'Main' )

	send Output
		~/*
		~ * main_gen.h
		~ */
		~
		~#ifndef _MAIN_GEN_H
		~#define _MAIN_GEN_H
		~
		~#include <genf/thread.h>
		~#include "itq_gen.h"
		~#include "packet_gen.h"
		~

	threadForwards( Thread )

	send Output
		~struct MainGen
		~	: public Thread
		~{
		~	MainGen() : Thread("main") {}
		~
		~	void init( int argc, char *const*argv )
		~	{
		~		this->argc = argc;
		~		this->argv = argv;
		~	}
		~
		~	int argc;
		~	char *const*argv;
		~
		~	void parseOptions();
		~	void maybeBackground();
		~	int start();
		~	void join();
		~	virtual int main() { return 0; }
		~
		~	void recvSingle();
		~	int recvLoop();
		~	bool poll();
		~	void recvHeader( ItQueue *queue, ItHeader *header );
		~
		~	virtual void data( SelectFd *fd );
		~	void close( SelectFd *fd );
		~
		~	void handleSignal( int sig );
		~	void signalSetup();
		~	int signalLoop( struct timeval *timer = 0 );
		~	int selectLoop( timeval *timer = 0, bool wantPoll = true );

	createChildDecls( Thread )
	sendsToDecls( Thread )
	optDefine( P )
	recvDecls( Thread )
	packetRecvDecls( Thread )

	send Output
		~};
		~
		~#endif

	send Output [] eos
	writeOutput( Output->tree, 'main_gen.h' )
}

void optString( P: program )
{
	send Output
		"const char optstring\[\] = \":"

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`- short]

			send Output [OS.short]
			if !match OD.option_type [`bool]
				send Output ":"
		}
	}

	send Output
		"\";
		"
}

void longOpts( P: ref<program> )
{
	send Output
		"const option longopts\[\] = {

	Ind: int = 0
	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`-- long]
			send Output
				"	{ \"[OS.long]\", "

			if match OD.option_type [`bool]
				send Output "no_argument"
			else
				send Output "required_argument"

			send Output
				", 0, 0 },

			# Save the index.
			OS.Ind = Ind
			Ind = Ind + 1
		}
	}

	send Output
		"	{ 0, 0, 0, 0 }
		"};
		"
}

void optDefine( P: program )
{
	Ind: int = 0
	for OD: option_def in P {
		switch OD.option_type
		case [`bool] {
			send Output
				"static bool [OD.id];
		}
		case [`string] {
			send Output
				"static const char *[OD.id];

		}
		case [`long] {
			send Output
				"static long [OD.id];
		}
		case [`string `list] {
			send Output
				"static OptStringList [OD.id];
		}
	}

	send Output "
}

void optDeclare( P: program )
{
	Ind: int = 0
	for OD: option_def in P {
		switch OD.option_type
		case [`bool] {
			send Output
				"bool MainGen::[OD.id] = false;
		}
		case [`string] {
			send Output
				"const char *MainGen::[OD.id] = 0;

		}
		case [`long] {
			send Output
				"long MainGen::[OD.id] = 0;
		}
		case [`string `list] {
			send Output
				"OptStringList MainGen::[OD.id];
		}
	}

	send Output "
}

void parseOption( P: program, OD: option_def, Src: str )
{
	if $OD.id == "__debug" {
		# Handle debug realms directly, rather than collecting into program
		# state.
		Else: str = ""
		for D: debug_def in P {
			send Output
				"	[Else]if ( strcmp( [Src], \"[D.id]\" ) == 0 )
				"		enabledRealms |= DBG_[D.id];
			Else = "else "
		}
		send Output
			"	else {
			"		log_FATAL( \"unrecognized debug realm: \" << [Src] );
			"	}
	}
	else {
		switch OD.option_type
		case [`bool] {
			send Output
				"[OD.id] = true;
		}
		case [`string] {
			send Output
				"[OD.id] = [Src];

		}
		case [`long] {
			send Output
				"char *eptr;
				"if ( *[Src] == 0 )
				"	log_FATAL( \"no characters found in [OD.id] (long) value\" );
				"
				"[OD.id] = strtol( [Src], &eptr, 10 );
				"
				"if ( *eptr != 0 )
				"	log_FATAL( \"invalid characters in [OD.id] (long) value: \" << [Src] );
				"if ( ( [OD.id] == LONG_MAX || [OD.id] == LONG_MIN) && errno == ERANGE )
				"	log_FATAL( \"[OD.id] (long) out of range: \" << [Src] );
				"if ( [OD.id] == 0 && errno != 0 )
				"	log_FATAL( \"failed to parse [OD.id] (long): \" << [Src] );
		}	
		case [`string `list] {
			send Output
				"{
				"	OptStringEl *el = new OptStringEl;
				"	el->data = [Src];
				"	el->next = 0;
				"	if ( [OD.id].tail == 0 )
				"		[OD.id].head = [OD.id].tail = el;
				"	else {
				"		[OD.id].tail->next = el;
				"		[OD.id].tail = el;
				"	}
				"}
				"
		}
	}
}

void parseOptions( P: ref<program> )
{
	send Output
		"void MainGen::parseOptions()
		"{
		"	while ( true ) {
		"		int option_index = 0;
		"		int c = getopt_long( argc, argv, optstring, longopts, &option_index );
		"		if ( c == -1 )
		"			break;
		"		switch ( c ) {

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`- short]

			send Output
				"			case '[OS.short]': {
				"				[parseOption( P, OD, 'optarg' )]
				"				break;
				"			}
		}
	}
	
	send Output
		"			case 0: {
		"				switch ( option_index ) {

	for OD: option_def in P {
		for OS: option_spec in OD {
			require OS [`-- long]
			send Output
				"				case [OS.Ind]:
				"					[parseOption( P, OD, '(argv[optind-1])' )]
				"					break;
		}
	}

	send Output
		"				}
		"				break;
		"			}
		"			case ':': 
		"			case '?': {
		"				const char *msg = ( c == '?' ) ? 
		"						\"unknown option: \" :
		"						\"missing argument for option: \";
		"
		"				if ( optopt == 0 )
		"					log_FATAL( msg << argv\[optind-1\] );
		"				else 
		"					log_FATAL( msg << \"-\" << (char)optopt );
		"				break;
		"			}
		"		}
		"	}
		"}
}

void generateMainCode( P: ref<program> )
{
	Output = new parser<out_c::out_c>()
	Thread: thread = ThreadMap->find( 'Main' )

	send Output
		~/*
		~ * main_gen.cc
		~ */
		~

	send Output
		~#include <iostream>
		~#include <unistd.h>
		~#include <getopt.h>
		~#include <errno.h>
		~#include <stdlib.h>
		~#include <limits.h>
		~#include <string.h>
		~#include <signal.h>
		~#include <sys/time.h>
		~#include <sys/types.h>
		~#include <sys/stat.h>
		~#include <fcntl.h>
		~#include <sys/capability.h>
		~#include <sys/prctl.h>
		~#include <linux/securebits.h>
		~#include <pwd.h>
		~
		~#include "main.h"
		~#include "genf.h"

	threadIncludes( Thread )
	send Output ~
	
	optString( P )
	longOpts( P )
	optDeclare( P )
	parseOptions( P )

	send Output
		~#define LOGFILE LOGDIR "/" PACKAGE ".log"
		~#define PIDFILE PIDDIR "/" PACKAGE ".pid"

	send Output
		~void on_exit(void)
		~{
		~	unlink( PIDFILE );
		~}

	send Output
		~
		~void MainGen::maybeBackground()
		~{
		~	if ( background ) {
		~		/* Ensure we can open the files we need to open. */
		~		int rdfd = open( "/dev/null", O_RDONLY );
		~		if ( rdfd == -1 )
		~			log_FATAL( "daemonize: could not open /dev/null for stdin replacement: " << strerror(errno) );
		~
		~		int lgfd = open( LOGFILE, O_WRONLY|O_APPEND|O_CREAT,
		~				S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH );
		~		if ( lgfd == -1 )
		~			log_FATAL( "daemonize: could not open log file: " << strerror(errno) );
		~
		~		FILE *pidf = fopen( PIDFILE, "w" );
		~		if ( pidf == NULL )
		~			log_FATAL( "daemonize: could not open pid file: " << strerror(errno) );
		~		
		~		/* Setup the pidfile unlink. Used on daemon failure and also in
		~		 * the detached child process. */
		~		atexit( on_exit );
		~
		~		/* Change dirs, but don't close fds. */
		~		int result = daemon( 0, 1 );
		~		if ( result == -1 )
		~			log_FATAL( "damonize: daemon() failed: " << strerror(errno) );
		~
		~		/* Redirect stdin from /dev/null. */
		~		dup2( rdfd, 0 );
		~		::close( rdfd );
		~
		~		/* Redirect stdout and stderr to the log file. This will capture
		~		 * the log file since it is writing to stderr. */
		~		dup2( lgfd, 1 );
		~		dup2( lgfd, 2 );
		~		::close( lgfd );
		~
		~		/* write the pid file. */
		~		pid_t pid = getpid();
		~		fprintf( pidf, "%ld\n", (long)pid );
		~		fclose( pidf );
		~	}
		~}

	createChildDefs( Thread )

	send Output
		~int MainGen::start()
		~{
		~	parseOptions();
		~	maybeBackground();
		~	signalSetup();
		~	return main();
		~}
		~

	#
	# Signal setup.
	#
	# Set a null sigusr handler for all threads to use. We use sigusr to break
	# from system calls and don't need to take action in the handler.
	#
	# Also mask the signals we wish to funnel to the main thread. All threads
	# will inherit this signal mask. The main thread uses an atomic unmask to
	# receive the sigs in the various loops it supports.
	#
	send Output
		~static void sigusrHandler( int s )
		~{
		~}
		~
		~
		~void MainGen::signalSetup()
		~{
		~	signal( SIGUSR1, sigusrHandler );
		~	signal( SIGUSR2, sigusrHandler );
		~
		~	sigset_t set;
		~	sigemptyset( &set );
		~
		~	funnelSigs( &set );
		~
		~	sigaddset( &set, SIGUSR1 );
		~	sigaddset( &set, SIGUSR2 );
		~
		~	pthread_sigmask( SIG_SETMASK, &set, 0 );
		~}
		~

	send Output
		~void MainGen::handleSignal( int sig )
		~{
		~	switch ( sig ) {
		~	case SIGHUP:
		~	{
		~		log_message( "received SIGHUP" );
		~		break;
		~	}
		~	case SIGINT:
		~	case SIGQUIT:
		~	case SIGKILL:
		~	case SIGTERM:
		~	{
		~		log_message( "breaking from signal loop" );
		~		breakLoop();
		~		break;
		~	}
		~	case SIGCHLD:
		~		/* Be quiet on a sigchld. */
		~		break;
		~	default: {
		~		log_message( "received sig: " << sig );
		~		break;
		~	}}
		~}
		~
		~int MainGen::signalLoop( struct timeval *timer )
		~{
		~	sigset_t set;
		~	sigfillset( &set );
		~
		~	sigemptyset( &set );
		~	funnelSigs( &set );
		~	sigaddset( &set, SIGUSR1 );
		~	sigaddset( &set, SIGUSR2 );
		~	pthread_sigmask( SIG_SETMASK, &set, 0 );
		~
		~	return Thread::signalLoop( &set, timer );
		~}
		~

	send Output
		~int MainGen::selectLoop( timeval *timer, bool wantPoll )
		~{
		~	sigset_t set;
		~	sigemptyset( &set );
		~
		~	signal( SIGHUP,  thread_funnel_handler );
		~	signal( SIGINT,  thread_funnel_handler );
		~	signal( SIGQUIT, thread_funnel_handler );
		~	signal( SIGKILL, thread_funnel_handler );
		~	signal( SIGTERM, thread_funnel_handler );
		~	signal( SIGCHLD, thread_funnel_handler );
		~
		~	return pselectLoop( &set, timer, wantPoll );
		~}

	joinDef( Thread )
	sendsToCode( Thread )
	packetReceives( Thread )

	threadRecveives( Thread )

	send Output
		~Thread *getThis();
		~
	
	send Output
		~void reportCaps()
		~{
		~	ssize_t len = 0;
		~	cap_t c = cap_get_proc();
		~	char *t = cap_to_text( c, &len );
		~	printf( "exec caps: %s\n", t );
		~	cap_free( t );
		~	cap_free( c );
		~}
		~
		~passwd *findRunAsUser()
		~{
		~	passwd *found = NULL, *pw;
		~	while ( (pw = getpwent()) ) {
		~		if ( strcmp( pw->pw_name, RUN_AS ) == 0 ) {
		~			found = pw;
		~			break;
		~		}
		~	}
		~
		~	if ( found == 0 )
		~		log_FATAL( "could not locate run-as user " RUN_AS );
		~
		~	return found;
		~}
		~
		~void switchToRunAs()
		~{
		~	passwd *runAs = findRunAsUser();
		~		
		~	int r = setgid( runAs->pw_gid );
		~	if ( r != 0 )
		~		log_FATAL( "setgid(" << runAs->pw_gid << ") failure: " << strerror(errno) );
		~
		~	r = setuid( runAs->pw_uid );
		~	if ( r != 0 )
		~		log_FATAL( "setuid(" << runAs->pw_uid << ") failure: " << strerror(errno) );
		~}
		~
	
	if GblNumCaps > 0  {
		send Output
			~void dropCaps()
			~{
			~	int r = 0;
			~
			~	if ( getuid() != 0 || getgid() != 0 )
			~		log_FATAL( "this service requires capabilities and must be started as root" );
			~
			~	/* Tell the system to not change caps (except clearing effective)
			~	 * when changing user ids. */
			~	prctl( PR_SET_KEEPCAPS, 1L );
			~
			~	/* Drop privs. */
			~	switchToRunAs();
			~
			~	/*
			~	 * Reduce caps to what we need.
			~	 */
			~	cap_t c = cap_get_proc();
			~
			~	cap_clear( c );
			~
			"	cap_value_t to_set\[\] = { [GblCapList] };
			"	r = cap_set_flag( c, CAP_PERMITTED, [GblNumCaps], to_set, CAP_SET );
			"	r = cap_set_flag( c, CAP_EFFECTIVE, [GblNumCaps], to_set, CAP_SET );
			~
			~	r = cap_set_proc( c );
			~	if ( r != 0 )
			~		log_FATAL( "cap_set_proc failure: " << strerror(errno) );
			~	cap_free( c );
			~}
			~
	}
	else {
		send Output
			~void dropCaps()
			~{
			~	if ( getuid() == 0 || getgid() == 0 )
			~		switchToRunAs();
			~}
	}

	send Output
		~int main( int argc, char *const*argv )
		~{
		~	genf::lf = new lfdostream( 2 );
		~	dropCaps();
		~	pthread_key_create( &Thread::thisKey, 0 );
		~	ares_library_init( 0);
		~	MainThread main;
		~	ares_init( &main.ac );
		~	main.initId();
		~	main.init( argc, argv );
		~	int r = main.start();
		~	ares_destroy( main.ac );
		~	ares_library_cleanup();
		~	return r;
		~}
		~

	send Output [] eos
	writeOutput( Output->tree, 'main_gen.cc' )
}
