
global ModuleName: id
global KobjList: list<kobj> = new list<kobj>

global AttrNum: int = 1

void attrDecl( Kobj: kobj AD: attr_decl )
{
	Attr: attr = new attr
	Attr->Name = $AD.id

	for Mod: attr_modifier in AD {
		if match Mod [`show]
			Attr->Show = true
		elsif match Mod [`store]
			Attr->Store = true
	}

	Attr->Num = AttrNum
	Kobj->Attrs->push_tail( Attr )

	AttrNum = AttrNum + 1
}

void semanticAnalysis( P: program )
{
	ModuleDecl: module_decl = module_decl in P
	if ModuleDecl
		ModuleName = ModuleDecl.id
	
	for ThreadDef: thread_def in P {
		Thread: thread = consThread( ThreadDef )[]
		ThreadMap->insert( $ThreadDef.id Thread )
	}

	for MessageDef: message_def in P {
		Message: message = consMessage( MessageDef )[]
		MessageMap->insert( $MessageDef.id Message )
	}

	for StartsDecl: starts_decl in P {
		Owner: thread = findThread( StartsDecl.Owner )
		Thread: thread = findThread( StartsDecl.Thread )
		Owner->Starts->push_tail( Thread )
	}

	for SendsTo: sends_to_decl in P {
		Sender: thread = findThread( SendsTo.Sender )
		Message: message = findMessage( SendsTo.Message )
		Receiver: thread = findThread( SendsTo.Receiver )

		# Record the sender->receiver relationship
		Sends: sends = Sender->SendsMap->find( Receiver )
		if ( !Sends ) {
			Sends = new sends
			Sends->Sender = Sender
			Sends->Receiver = Receiver
			Sends->MessageList = new list<message>

			Sender->SendsMap->insert( Receiver Sends )
		}
		Sends->MessageList->push_tail( Message )
		Receiver->RecvsList->push_tail( Message )
	}

	# Make the root kobj.
	RootKobj: kobj = new kobj
	RootKobj->TypeName = $ModuleName
	RootKobj->Attrs = new list<attr>

	KobjList->push_tail( RootKobj )

	# Find the root attributes
	match P [DefList: definition*]
	for Def: definition in repeat( DefList ) {
		if match Def [AD: attr_decl]
			attrDecl( RootKobj AD )
	}

	for KD: kobj_def in P {
		Kobj: kobj = new kobj
		Kobj->TypeName = $KD.id
		Kobj->Attrs = new list<attr>
		for AD: attr_decl in KD 
			attrDecl( Kobj AD )
		KobjList->push_tail( Kobj )
	}
}
