context thread
	Id: str
	Lower: str
	Upper: str
	Starts: list<thread>
	StartedBy: thread
	SendsMap: map<thread, sends>
	RecvsList: list<message>
	SendsPktList: list<packet>
	RecvsPktList: list<packet>
end

context message
	Id: str
	MessageDef: message_def
end

context packet
	Id: str
	PacketDef: packet_def
	NumID: int
end

context sends
	Sender: thread
	Receiver: thread
	MessageList: list<message>
end

context attr
	Name: str
	Num: int
	Show: bool
	Store: bool
	ArgList: attr_arg_list?
end

context kobj
	TypeName: str
	Attrs: list<attr>
end

#
# Thread map.
#

global ThreadMap: map<str, thread> = new map<str, thread>()

thread findThread( Id: id )
{
	Thread: thread = ThreadMap->find( $Id )
	if ! Thread {
		send stderr "[OptInputFn]:[Id.line]: failed to locate thread [Id]
		exit( 1 )
	}
	return Thread
}

thread consThread( ThreadDef: thread_def )
{
	Thread: thread = new thread()
	Thread->Id = $ThreadDef.id
	Thread->Lower = tolower( Thread->Id )
	Thread->Upper = toupper( Thread->Id )
	Thread->Starts = new list<thread>()
	Thread->SendsMap = new map<thread, sends>()
	Thread->RecvsList = new list<message>()
	Thread->SendsPktList = new list<packet>()
	Thread->RecvsPktList = new list<packet>()
	return Thread
}

#
# Message Map
#
global MessageMap: map<str, message> = new map<str, message>()

message findMessage( Id: id )
{
	Message: message = MessageMap->find( $Id )
	if ! Message {
		send stderr "[OptInputFn]:[Id.line]: failed to locate message [Id]
		exit( 1 )
	}
	return Message
}

message consMessage( MessageDef: message_def )
{
	Message: message = new message()
	Message->Id = $MessageDef.id
	Message->MessageDef = MessageDef
	return Message
}

#
# Packet Map
#
global PacketMap: map<str, packet> = new map<str, packet>()

packet findPacket( Id: id )
{
	Packet: packet = PacketMap->find( $Id )
	if ! Packet {
		send stderr "[OptInputFn]:[Id.line]: failed to locate packet [Id]
		exit( 1 )
	}
	return Packet
}

packet consPacket( PacketDef: packet_def )
{
	Packet: packet = new packet()
	Packet->Id = $PacketDef.id
	Packet->PacketDef = PacketDef
	return Packet
}

#
# Kernel Support
#

global ModuleName: id
global KobjList: list<kobj> = new list<kobj>()

global AttrNum: int = 1

void attrDecl( Kobj: kobj, AD: attr_decl )
{
	Attr: attr = new attr()
	Attr->Name = $AD.id

	for Mod: attr_modifier in AD {
		if match Mod [`show]
			Attr->Show = true
		elsif match Mod [`store]
			Attr->Store = true
	}

	Attr->Num = AttrNum
	Attr->ArgList = AD.ArgSpec.List
	Kobj->Attrs->push_tail( Attr )

	AttrNum = AttrNum + 1
}

void semanticAnalysis( P: program )
{
	ModuleDecl: module_decl = module_decl in P
	if ModuleDecl
		ModuleName = ModuleDecl.id
	
	for ThreadDef: thread_def in P {
		Thread: thread = consThread( ThreadDef )[]
		ThreadMap->insert( $ThreadDef.id, Thread )
	}

	for MessageDef: message_def in P {
		Message: message = consMessage( MessageDef )[]
		MessageMap->insert( $MessageDef.id, Message )
	}

	for PacketDef: packet_def in P {
		Packet: packet = consPacket( PacketDef )[]
		PacketMap->insert( $PacketDef.id, Packet )
	}

	ID: int = 1
	for Packet: packet in PacketMap {
		Packet->NumID = ID
		ID = ID + 1
	}

	for Use: use_decl in P {
		print "use [Use.string]
		S: str = $Use.string
		S = S.suffix( 1 )
		S = S.prefix( S.length - 1 )

		Found: stream

		for Path: str in OptInc {
			print "checking [Path]/[S]
			
			Try: str = "[Path]/[S]"
			Input: stream = open( Try, 'r' )

			if ( Input ) {
				Found = Input
				break
			}
		}

		if ( !Found ) {
			send stderr "ERROR: could not find file for use statment: [Use]
			exit( 1 )
		}

		UseP: program = parse program [Found]
		if ( !UseP ) {
			send stderr "ERROR: could not parse input: [error]
			exit( 1 )
		}

		UsePacketMap: map<str, packet> = new map<str, packet>()
		for PacketDef: packet_def in UseP {
			Packet: packet = consPacket( PacketDef )[]
			UsePacketMap->insert( $PacketDef.id, Packet )
		}

		ID: int = 1
		for Packet: packet in UsePacketMap {
			Packet->NumID = ID
			ID = ID + 1
		}

		for Packet: packet in UsePacketMap
			PacketMap->insert( Packet->Id, Packet )
	}


	for StartsDecl: starts_decl in P {
		Owner: thread = findThread( StartsDecl.Owner )
		Thread: thread = findThread( StartsDecl.Thread )
		Owner->Starts->push_tail( Thread )
	}

	for SendsTo: sends_to_decl in P {
		Sender: thread = findThread( SendsTo.Sender )
		Message: message = findMessage( SendsTo.Message )
		Receiver: thread = findThread( SendsTo.Receiver )

		# Record the sender->receiver relationship
		Sends: sends = Sender->SendsMap->find( Receiver )
		if ( !Sends ) {
			Sends = new sends()
			Sends->Sender = Sender
			Sends->Receiver = Receiver
			Sends->MessageList = new list<message>()

			Sender->SendsMap->insert( Receiver, Sends )
		}
		Sends->MessageList->push_tail( Message )
		Receiver->RecvsList->push_tail( Message )
	}

	for Sends: sends_decl in P {
		Sender: thread = findThread( Sends.Sender )
		Packet: packet = findPacket( Sends.Packet )
		Sender->SendsPktList->push_tail( Packet )
	}

	for Receives: receives_decl in P {
		Receiver: thread = findThread( Receives.Receiver )
		Packet: packet = findPacket( Receives.Packet )
		Receiver->RecvsPktList->push_tail( Packet )
	}

	# Make the root kobj.
	RootKobj: kobj = new kobj()
	RootKobj->TypeName = $ModuleName
	RootKobj->Attrs = new list<attr>()

	KobjList->push_tail( RootKobj )

	# Find the root attributes
	match P [DefList: definition*]
	for Def: definition in repeat( DefList ) {
		if match Def [AD: attr_decl]
			attrDecl( RootKobj, AD )
	}

	for KD: kobj_def in P {
		Kobj: kobj = new kobj()
		Kobj->TypeName = $KD.id
		Kobj->Attrs = new list<attr>()
		for AD: attr_decl in KD 
			attrDecl( Kobj, AD )
		KobjList->push_tail( Kobj )
	}
}
