context thread
	Id: str
	Lower: str
	Upper: str
	Starts: vlist<thread>
	StartedBy: thread
	SendsMap: vmap<thread, sends>
	RecvsList: vlist<message>
end

context message
	Id: str
	MessageDef: message_def
end

context sends
	Sender: thread
	Receiver: thread
	MessageList: vlist<message>
end

context attr
	Name: str
	Num: int
	Show: bool
	Store: bool
	ArgList: attr_arg_list?
end

context kobj
	TypeName: str
	Attrs: vlist<attr>
end

#
# Thread map.
#

global ThreadMap: vmap<str, thread> = new vmap<str, thread>()

thread findThread( Id: id )
{
	Thread: thread = ThreadMap->find( $Id )
	if ! Thread {
		send stderr "inp:[Id.line]: failed to locate thread [Id]
		exit( 1 )
	}
	return Thread
}

thread consThread( ThreadDef: thread_def )
{
	Thread: thread = new thread()
	Thread->Id = $ThreadDef.id
	Thread->Lower = tolower( Thread->Id )
	Thread->Upper = toupper( Thread->Id )
	Thread->Starts = new vlist<thread>()
	Thread->SendsMap = new vmap<thread, sends>()
	Thread->RecvsList = new vlist<message>()
	return Thread
}

#
# Message map.
#
global MessageMap: vmap<str, message> = new vmap<str, message>()

message findMessage( Id: id )
{
	Message: message = MessageMap->find( $Id )
	if ! Message {
		send stderr "inp:[Id.line]: failed to locate message [Id]
		exit( 1 )
	}
	return Message
}

message consMessage( MessageDef: message_def )
{
	Message: message = new message()
	Message->Id = $MessageDef.id
	Message->MessageDef = MessageDef
	return Message
}


global ModuleName: id
global KobjList: vlist<kobj> = new vlist<kobj>()

global AttrNum: int = 1

void attrDecl( Kobj: kobj, AD: attr_decl )
{
	Attr: attr = new attr()
	Attr->Name = $AD.id

	for Mod: attr_modifier in AD {
		if match Mod [`show]
			Attr->Show = true
		elsif match Mod [`store]
			Attr->Store = true
	}

	Attr->Num = AttrNum
	Attr->ArgList = AD.ArgSpec.List
	Kobj->Attrs->push_tail( Attr )

	AttrNum = AttrNum + 1
}

void semanticAnalysis( P: program )
{
	ModuleDecl: module_decl = module_decl in P
	if ModuleDecl
		ModuleName = ModuleDecl.id
	
	for ThreadDef: thread_def in P {
		Thread: thread = consThread( ThreadDef )[]
		ThreadMap->insert( $ThreadDef.id, Thread )
	}

	for MessageDef: message_def in P {
		Message: message = consMessage( MessageDef )[]
		MessageMap->insert( $MessageDef.id, Message )
	}

	for StartsDecl: starts_decl in P {
		Owner: thread = findThread( StartsDecl.Owner )
		Thread: thread = findThread( StartsDecl.Thread )
		Owner->Starts->push_tail( Thread )
	}

	for SendsTo: sends_to_decl in P {
		Sender: thread = findThread( SendsTo.Sender )
		Message: message = findMessage( SendsTo.Message )
		Receiver: thread = findThread( SendsTo.Receiver )

		# Record the sender->receiver relationship
		Sends: sends = Sender->SendsMap->find( Receiver )
		if ( !Sends ) {
			Sends = new sends()
			Sends->Sender = Sender
			Sends->Receiver = Receiver
			Sends->MessageList = new vlist<message>()

			Sender->SendsMap->insert( Receiver, Sends )
		}
		Sends->MessageList->push_tail( Message )
		Receiver->RecvsList->push_tail( Message )
	}

	# Make the root kobj.
	RootKobj: kobj = new kobj()
	RootKobj->TypeName = $ModuleName
	RootKobj->Attrs = new vlist<attr>()

	KobjList->push_tail( RootKobj )

	# Find the root attributes
	match P [DefList: definition*]
	for Def: definition in repeat( DefList ) {
		if match Def [AD: attr_decl]
			attrDecl( RootKobj, AD )
	}

	for KD: kobj_def in P {
		Kobj: kobj = new kobj()
		Kobj->TypeName = $KD.id
		Kobj->Attrs = new vlist<attr>()
		for AD: attr_decl in KD 
			attrDecl( Kobj, AD )
		KobjList->push_tail( Kobj )
	}
}
