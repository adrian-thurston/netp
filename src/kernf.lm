def attr
	Name: str
	[]

alias attr_list
	list<ptr<attr>>

def kobj
	TypeName: str
	ShowAttrs: attr_list
	StoreAttrs: attr_list
	[]

void attribute( Attr: ptr<attr> )
{
	send Output
		"static int [Attr->Name];
		"
		"static ssize_t [Attr->Name]_show( struct kobject *kobj, struct 
		"		[ModuleName]_attribute *attr, char *buf )
		"{
		"	return sprintf( buf, \"%d\\n\", [Attr->Name] );
		"}
		"
		"static ssize_t [Attr->Name]_store( struct kobject *kobj,
		"		struct [ModuleName]_attribute *attr, const char *buf, size_t count )
		"{
		"	sscanf( buf, \"%du\", &[Attr->Name] );
		"	return count;
		"}
		"
		"static struct [ModuleName]_attribute [Attr->Name]_attribute =
		"	__ATTR( [Attr->Name], 0666, 1, 2 );
		"
}

void module_c( P: program )
{
	Output = cons parser<out_c::out_c>[]

	send Output
		"#include <linux/kernel.h>
		"#include <linux/module.h>
		"#include <linux/init.h>
		"#include <linux/kobject.h>
		"#include <linux/slab.h>
		"
		"/* Lie to make it compile. */
		"MODULE_LICENSE( \"GPL\" );
		"MODULE_AUTHOR( \"Colm Networks\" );
		"MODULE_DESCRIPTION( \"[ModuleName]\" );
		"
		"struct [ModuleName]
		"{
		"	struct kobject kobj;
		"};
		"
		"static struct [ModuleName] *root_obj;
		"
		"struct [ModuleName]_attribute
		"{
		"	struct attribute attr;
		"	unsigned int show;
		"	unsigned int store;
		"};
		"

	match P [DefList: definition*]
	for Attr: ptr<attr> in RootKobj->ShowAttrs
		attribute( Attr )

	send Output
		"static struct attribute *[ModuleName]_attrs\[\] = {

	for Attr: ptr<attr> in RootKobj->ShowAttrs {
		send Output
			"	&[Attr->Name]_attribute.attr,
	}

	send Output
		"	NULL,
		"};
		"
		"static struct attribute_group [ModuleName]_attr_group = {
		"	.attrs = [ModuleName]_attrs,
		"};
		"
		"static void [ModuleName]_release( struct kobject *kobj )
		"{
		"	// kfree(kobj);
		"}
		"
		"static ssize_t [ModuleName]_attr_show( struct kobject *kobj, 
		"		struct attribute *attr, char *buf)
		"{
		"	struct [ModuleName]_attribute *kattr;
		"	ssize_t ret = -EIO;
		"
		"	kattr = container_of( attr, struct [ModuleName]_attribute, attr );
		"	switch ( kattr->show ) {
		"		case 1:
		"			ret = fuzz_show( kobj, kattr, buf );
		"			break;
		"	}
		"	return ret;
		"}
		"
		"static ssize_t [ModuleName]_attr_store( struct kobject *kobj,
		"		struct attribute *attr, const char *buf, size_t count )
		"{
		"	struct [ModuleName]_attribute *kattr;
		"	ssize_t ret = -EIO;
		" 
		"	kattr = container_of( attr, struct [ModuleName]_attribute, attr );
		"	switch ( kattr->store ) {
		"		case 2:
		"			ret = fuzz_store( kobj, kattr, buf, count );
		"			break;
		"	}
		"	return ret;
		"}
		"
		"const struct sysfs_ops [ModuleName]_sysfs_ops = {
		"	.show   = [ModuleName]_attr_show,
		"	.store  = [ModuleName]_attr_store,
		"};
		"
		"EXPORT_SYMBOL_GPL([ModuleName]_sysfs_ops);
		"
		"static struct kobj_type [ModuleName]_ktype = {
		"	.release        = [ModuleName]_release,
		"	.sysfs_ops      = &[ModuleName]_sysfs_ops,
		"};
		"

	send Output
		"static int __init [ModuleName]_init( void )
		"{
		"	int retval;
		"	printk( KERN_INFO \"[ModuleName] init\\n\" );
		"
		"	root_obj = kzalloc( sizeof(*root_obj), GFP_KERNEL );
		"	if ( ! root_obj )
		"		return -ENOMEM;
		"
		"	kobject_init( &root_obj->kobj, &[ModuleName]_ktype );
		" 	kobject_add( &root_obj->kobj, NULL, \"[ModuleName]\" );
#		" 	if ( retval ) {
#		"		printk(KERN_WARNING "%s: kobject_add error: %d\n", __func__, retval);
#		"		kobject_put(kobj);
#		"		kobj = NULL;
#		"	}
#		"	return kobj;
		"
		"	retval = sysfs_create_group( &root_obj->kobj, &[ModuleName]_attr_group );
		"	if ( retval )
		"		kobject_put( &root_obj->kobj );
		"
		"	return 0;
		"}
		"
		"static void __exit [ModuleName]_exit(void)
		"{
		"	printk( KERN_INFO \"[ModuleName] exit\\n\" );
		"
		"	kobject_put( &root_obj->kobj );
		"}
		"
		"module_init( [ModuleName]_init );
		"module_exit( [ModuleName]_exit );

	send Output [] eos
	writeOutput( Output.tree 'module.c' )
}

void makefile( P: program )
{
	Output = cons parser<out_c::out_c>[]

	send Output
		"obj-m := [ModuleName].o
		"[ModuleName]-objs := module.o

	send Output [] eos
	writeOutput( Output.tree 'Kbuild' )
}

void generateKernf( P: program )
{
	if !ModuleName {
		send stderr "module name not specified in input
		exit( 1 )
	}

	module_c( P )
	makefile( P )
}
