void attribute( Attr: id )
{
	send Output
		"static int [Attr];
		"
		"static ssize_t [Attr]_show( struct kobject *kobj, struct 
		"		kobj_attribute *attr, char *buf )
		"{
		"	return sprintf( buf, \"%d\\n\", [Attr] );
		"}
		"
		"static ssize_t [Attr]_store( struct kobject *kobj,
		"		struct kobj_attribute *attr, const char *buf, size_t count )
		"{
		"	sscanf(buf, \"%du\", &[Attr]);
		"	return count;
		"}
		"
		"static struct kobj_attribute [Attr]_attribute =
		"	__ATTR( [Attr], 0666, [Attr]_show, [Attr]_store );
		"
}

void module_c( P: program )
{
	Output = cons parser<out_c::out_c>[]

	send Output
		"#include <linux/kernel.h>
		"#include <linux/module.h>
		"#include <linux/init.h>
		"#include <linux/kobject.h>
		"
		"/* Lie to make it compile. */
		"MODULE_LICENSE( \"GPL\" );
		"MODULE_AUTHOR( \"Colm Networks\" );
		"MODULE_DESCRIPTION( \"[ModuleName]\" );
		"
		"static struct kobject *[ModuleName]_kobj;
		"

	match P [DefList: definition*]
	for Def: definition in repeat( DefList ) {
		if match Def [AD: attribute_decl]
			attribute( AD.id )
	}


	send Output
		"static struct attribute *attrs\[\] = {

	for Def: definition in repeat( DefList ) {
		if match Def [AD: attribute_decl] {
			send Output
				"	&[AD.id]_attribute.attr,
		}
	}

	send Output
		"	NULL,
		"};
		"
		"static struct attribute_group attr_group = {
		"	.attrs = attrs,
		"};
		"

	send Output
		"static int __init [ModuleName]_init(void)
		"{
		"	int retval;
		"	printk( KERN_INFO \"[ModuleName] init\\n\" );
		"
		"	[ModuleName]_kobj = kobject_create_and_add( \"[ModuleName]\", NULL );
		"	if ( ![ModuleName]_kobj )
		"		return -ENOMEM;
		"
		"	retval = sysfs_create_group( [ModuleName]_kobj, &attr_group );
		"	if ( retval )
		"		kobject_put( [ModuleName]_kobj );
		"
		"	return 0;
		"}
		"
		"static void __exit [ModuleName]_exit(void)
		"{
		"	printk( KERN_INFO \"[ModuleName] exit\\n\" );
		"
		"	kobject_put( [ModuleName]_kobj );
		"}
		"
		"module_init( [ModuleName]_init );
		"module_exit( [ModuleName]_exit );

	send Output [] eos
	writeOutput( Output.tree 'module.c' )
}

void makefile( P: program )
{
	Output = cons parser<out_c::out_c>[]

	send Output
		"obj-m := [ModuleName].o
		"[ModuleName]-objs := module.o

	send Output [] eos
	writeOutput( Output.tree 'Kbuild' )
}

void generateKernf( P: program )
{
	if !ModuleName {
		send stderr "module name not specified in input
		exit( 1 )
	}

	module_c( P )
	makefile( P )
}
