void generatePacketHeader( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.h
		~ */
		~
		~#ifndef __PACKET_GEN_H
		~#define __PACKET_GEN_H
		~
		~#include <sys/types.h>
		~#include <sys/socket.h>
		~
		~struct PacketWriter;
		~

	ID: int = 1

	for Packet: packet in PacketMap {
		send Output
			"struct [Packet->Id]
			"{

		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
			}
			case [`long] {
				send Output
					"	long [FD.id];
			}
			case [`string] {
				send Output
					"	const char *[FD.id];
			}
		}

		send Output
			"	static [Packet->Id] *open( PacketWriter *writer );
			"	static void send( PacketWriter *writer );
			"	static const unsigned short ID = [ID];
			"};
			"

		ID = ID + 1
	}

	send Output
		~#endif
		eos

	writeOutput( Output->tree, 'packet_gen.h' )
}

void packetReceives( Thread: thread )
{
	send Output
		"#include \"packet_gen.h\"
		"
		"void [Thread->Id]Gen::data( SelectFd *fd )
		"{
		"	log_message( \"select in data call\" );
		"	PacketHeader packetHeader;
		"	int len = read( fd->fd, &packetHeader, sizeof(packetHeader) );
		"	log_message( \"header read: \" << len );
		"	if ( len == 0 ) {
		"		close( fd );
		"		return;
		"	}
		"
		"	switch ( packetHeader.msgId )  {

	for Packet: packet in Thread->RecvsPktList {
		send Output
			"		case (int) [Packet->Id]::ID: {
			"			StatsQuery sq;
			"			len = read( fd->fd, &sq, sizeof(sq) );
			"			if ( len == 0 ) {
			"				close( fd );
			"				return;
			"			}
			"			log_message( \"received StatsQuery\" );
			"			break;
			"		}
	}

	send Output
		"	}
		"}
		"
		"void [Thread->Id]Gen::close( SelectFd *fd )
		"{
		"	log_message( \"closing: \" << fd->fd );
		"	::close( fd->fd );
		"	selectFdList.detach( fd );
		"	delete fd;
		"}   
		"
}


void generatePacketCode( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.cc
		~ */
		~
		~#include "packet_gen.h"
		~#include <genf/thread.h>
		~

	for PD: packet_def in P {
		send Output
			"[PD.id] *[PD.id]::open( PacketWriter *writer )
			"{
			"	writer->mlen = 0;
			"
			"	/* Place the header. */
			"	int offset = writer->allocBytes( sizeof(PacketHeader) );
			"	PacketHeader *header = (PacketHeader*) ( writer->data() + offset );
			"	
			"	header->msgId = [PD.id]::ID;
			"	header->writerId = 1; // writer->id;
			"
			"	/* Place the struct. */
			"	offset = writer->allocBytes( sizeof([PD.id]) );
			"	[PD.id] *msg = ([PD.id]*) ( writer->data() + offset );
			"
			"	header->length = writer->mlen;
			"	writer->toSend = header;
			"
			"	return msg;
			"}
			"

		send Output
			"void [PD.id]::send( PacketWriter *writer )
			"{
			"	log_message( \"sending \" << writer->length() << \" bytes\" );
			"	::write( writer->fd, writer->data(), writer->length() );
			"}
			"
	}

	send Output [] eos

	writeOutput( Output->tree, 'packet_gen.cc' )
}
