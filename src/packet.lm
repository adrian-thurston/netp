void generatePacketHeader( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.h
		~ */
		~
		~#ifndef __PACKET_GEN_H
		~#define __PACKET_GEN_H
		~
		~#include <sys/types.h>
		~#include <sys/socket.h>
		~#include <errno.h>
		~
		~struct PacketWriter;
		~

	for Packet: packet in PacketMap {
		send Output
			"struct [Packet->Id]
			"{

		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
			}
			case [`long] {
				send Output
					"	long [FD.id];
			}
			case [`string] {
				send Output
					"	char *[FD.id];
					"	void set_[FD.id]( PacketWriter *writer, const char *d );
			}
		}

		send Output
			"	static [Packet->Id] *open( PacketWriter *writer );
			"	static void send( PacketWriter *writer );
			"	static const unsigned short ID = [Packet->AppID * 1000 + Packet->NumID];
			"};
			"
	}

	send Output
		~#endif
		eos

	writeOutput( Output->tree, 'packet_gen.h' )
}

void packetRecvDecls( Thread: thread )
{
	for Packet: packet in Thread->RecvsPktList {
		send Output
			"	virtual void recv[Packet->Id]( SelectFd *fd, [Packet->Id] *pkt ) = 0;
	}
}

void packetReceives( Thread: thread )
{
	send Output
		"void [Thread->Id]Gen::data( SelectFd *fd )
		"{
		"	Connection *c = static_cast<Connection*>(fd->local);
		"	switch ( fd->recv.state ) {
		"	case SelectFd::Recv::WantHead: {
		"		const int sz = sizeof(fd->recv.head);
		"		int len = c->read( (char*)&fd->recv.head + fd->recv.have, sz - fd->recv.have );
		"		if ( len < 0 ) {
		"			if ( errno == EAGAIN || errno == EWOULDBLOCK ) {
		"				log_debug( DBG__PKTRECV, \"packet head read delayed: : \" << strerror(errno) );
		"				return;
		"			}
		"			else {
		"				/* fatal error. */
		"				log_debug( DBG__PKTRECV, \"packet head read failed: : \" << strerror(errno) );
		"			}
		"		}
		"		else if ( len == 0 ) {
		"			log_debug( DBG__PKTRECV, \"packet head read returned zero\" );
		"
		"			/* EOF. */
		"			close( fd );
		"			return;
		"		}
		"		else if ( fd->recv.have + len < sz )  {
		"			log_debug( DBG__PKTRECV, \"packet head read is short: \" << len << \" bytes\" );
		"
		"			/* Don't have it all. Need to wait for more. */
		"			fd->recv.have += len;
		"			return;
		"		}
		"
		"		if ( len > 0 ) {
		"			log_debug( DBG__PKTRECV, \"packet head read returned: \" << len << \" bytes\" );
		"		}
		"
		"		/* Completed read of header. */
		"		fd->recv.nextLen = &fd->recv.head.firstLen;
		"		fd->recv.state = SelectFd::Recv::WantBlock;
		"	
		"		fd->recv.need = *fd->recv.nextLen;
		"		fd->recv.have = 0;
		"
		"		/* Deliberate fall through. */
		"		fd->recv.data = fd->recv.buf.appendBlock( fd->recv.need );
		"	}
		"
		"	case SelectFd::Recv::WantBlock: {
		"		while ( true ) {
		"			while ( fd->recv.have < fd->recv.need ) {
		"				int len = c->read( fd->recv.data + fd->recv.have, fd->recv.need - fd->recv.have );
		"				if ( len < 0 ) {
		"					/* Error. */
		"					if ( errno == EAGAIN || errno == EWOULDBLOCK ) {
		"						/* continue. */
		"						log_debug( DBG__PKTRECV, \"packet data read delayed: : \" << strerror(errno) );
		"						return;
		"					}
		"					else {
		"						log_debug( DBG__PKTRECV, \"packet data read failed: : \" << strerror(errno) );
		"						/* fatal error. */
		"					}
		"				}
		"				else if ( len == 0 ) {
		"					log_debug( DBG__PKTRECV, \"packet data read returned zero\" );
		"					/* EOF. */
		"					close( fd );
		"					return;
		"				}
		"				else if ( fd->recv.have + len < fd->recv.need )  {
		"					log_debug( DBG__PKTRECV, \"packet data read is short: \" << len << \" bytes\" );
		"					/* Don't have it all. Need to wait for more. */
		"					fd->recv.have += len;
		"					return;
		"				}
		"
		"				if ( len > 0 ) {
		"					log_debug( DBG__PKTRECV, \"packet data read returned: \" << len << \" bytes\" );
		"					fd->recv.have += len;
		"				}
		"			}
		"
		"			fd->recv.nextLen = (int*)fd->recv.data;
		"			if ( *fd->recv.nextLen == 0 )
		"				break;
		"
		"			fd->recv.need = *fd->recv.nextLen;
		"			fd->recv.have = 0;
		"			fd->recv.data = fd->recv.buf.appendBlock( fd->recv.need );
		"		}
		"
		"		fd->recv.state = SelectFd::Recv::WantHead;
		"		fd->recv.need = 0;
		"		fd->recv.have = 0;
		"		switch ( fd->recv.head.msgId ) {

	for Packet: packet in Thread->RecvsPktList {
		send Output
			"			case (int) [Packet->Id]::ID: {
			"			[Packet->Id] *pkt = ([Packet->Id]*) pktFind( &fd->recv.buf, sizeof(PacketBlockHeader) );
		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`string] {
				send Output
					"			pkt->[FD.id] = pktFind( &fd->recv.buf, (long)pkt->[FD.id] );
			}
		}
		send Output
			"				recv[Packet->Id]( fd, pkt );
			"				break;
			"			}
	}

	send Output
		"		}
		"		fd->recv.buf.empty();
		"		break;
		"	}}
		"}
		"
		"void [Thread->Id]Gen::close( SelectFd *fd )
		"{
		"	::close( fd->fd );
		"	fd->closed = true;
		"}   
		"
}


void generatePacketCode( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.cc
		~ */
		~
		~#include "itq_gen.h"
		~#include "packet_gen.h"
		~#include <genf/thread.h>
		~

	for Packet: packet in PacketMap {
		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`string] {
				send Output
					"void [Packet->Id]::set_[FD.id]( PacketWriter *writer, const char *src )
					"{
					"	int length = strlen( src ) + 1;
					"	long offset = 0;
					"	char *dest = writer->allocBytes( length, offset );
					"	(([Packet->Id]*)writer->content)->[FD.id] = (char*)offset;
					"	memcpy( dest, src, length );
					"}
					"
			}
		}

		send Output
			"[Packet->Id] *[Packet->Id]::open( PacketWriter *writer )
			"{
			"	writer->reset();
			"
			"	/* Place the header. */
			"	PacketHeader *header = (PacketHeader*) writer->buf.append(
			"			0, sizeof(PacketHeader) + sizeof(PacketBlockHeader) );
			"	
			"	header->msgId = [Packet->Id]::ID;
			"	header->writerId = 1; // writer->id;
			"
			"	/* Place the struct. */
			"	long offset = 0;
			"	[Packet->Id] *msg = ([Packet->Id]*) writer->allocBytes( sizeof([Packet->Id]), offset );
			"
			"	header->length = 0;
			"	writer->toSend = header;
			"	writer->content = msg;
			"
			"	return msg;
			"}
			"

		#
		# format:
		#   PacketHeader, which contains first len, then ( nextLen, block )*
		#
		# The block lengths include the size of the nextLen field (int)
		#

		send Output
			"void [Packet->Id]::send( PacketWriter *writer )
			"{
			"	RopeBlock *rb = writer->buf.hblk;
			"	Connection *c = static_cast<Connection*>(writer->fd->local);
			"
			"	writer->toSend->length = writer->length();
			"	writer->toSend->firstLen = writer->buf.length(rb) - sizeof(PacketHeader);
			"
			"	int n = 0;
			"	for ( ; rb != 0; rb = rb->next ) {
			"		char *data = writer->buf.data(rb);
			"		int blockLen = writer->buf.length(rb);
			"
			"		int *nextLen;
			"		if ( n == 0 ) {
			"			/* First block explicitly contains the packet block header. */
			"			nextLen = (int*)(data + sizeof(PacketHeader));
			"		}
			"		else {
			"			nextLen = (int*)(data);
			"		}

			"		*nextLen = rb->next != 0 ? writer->buf.length(rb->next) : 0;
			"
			"		int res = c->write( data, blockLen );
			"		log_debug( DBG__PKTSEND, \"packet send result: \" << res );
			"
			"		n += 1;
			"	}
			"
			"	writer->buf.empty();
			"}
			"
	}

	send Output [] eos

	writeOutput( Output->tree, 'packet_gen.cc' )
}
