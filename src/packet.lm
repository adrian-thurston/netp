void generatePacketHeader( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.h
		~ */
		~
		~#ifndef __PACKET_GEN_H
		~#define __PACKET_GEN_H
		~
		~#include <sys/types.h>
		~#include <sys/socket.h>
		~
		~struct PacketWriter;
		~

	ID: int = 1

	for Packet: packet in PacketMap {
		send Output
			"struct [Packet->Id]
			"{

		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
			}
			case [`long] {
				send Output
					"	long [FD.id];
			}
			case [`string] {
				send Output
					"	char *[FD.id];
					"	void set_[FD.id]( PacketWriter *writer, const char *d );
			}
		}

		send Output
			"	static [Packet->Id] *open( PacketWriter *writer );
			"	static void send( PacketWriter *writer );
			"	static const unsigned short ID = [ID];
			"};
			"

		ID = ID + 1
	}

	send Output
		~#endif
		eos

	writeOutput( Output->tree, 'packet_gen.h' )
}

void packetRecvDecls( Thread: thread )
{
	for Packet: packet in Thread->RecvsPktList {
		send Output
			"	virtual void recv[Packet->Id]( SelectFd *fd, [Packet->Id] *pkt ) = 0;
	}
}

void packetReceives( Thread: thread )
{
	send Output
		"void [Thread->Id]Gen::data( SelectFd *fd )
		"{
		"	PacketHeader header;
		"	int len = ::read( fd->fd, &header, sizeof(header) );
		"	if ( len == 0 ) {
		"		close( fd );
		"		return;
		"	}
		"
		"	switch ( header.msgId )  {

	for Packet: packet in Thread->RecvsPktList {
		send Output
			"		case (int) [Packet->Id]::ID: {
			"			char data\[8192*2\];
			"			[Packet->Id] *pkt = ([Packet->Id]*)data;
			"			int have = 0, need = header.length - sizeof(header);
			"			while ( have < need ) {
			"				int len = ::read( fd->fd, data+have, need-have );
			"				if ( len < 0 ) {
			"					/* try again */
			"					sleep(1);
			"				}
			"				else if ( len == 0 ) {
			"					log_ERROR( \"unexpected read result\" );
			"					close( fd );
			"					return;
			"				}
			"				else {
			"					have += len;
			"				}
			"			}
		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`string] {
				send Output
					"	pkt->[FD.id] = data + (long)pkt->[FD.id]-sizeof(header);
			}
		}
		send Output
			"			recv[Packet->Id]( fd, pkt );
			"			break;
			"		}
	}

	send Output
		"	}
		"}
		"
		"void [Thread->Id]Gen::close( SelectFd *fd )
		"{
		"	::close( fd->fd );
		"	selectFdList.detach( fd );
		"	delete fd;
		"}   
		"
}


void generatePacketCode( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.cc
		~ */
		~
		~#include "packet_gen.h"
		~#include <genf/thread.h>
		~

	for Packet: packet in PacketMap {
		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`string] {
				send Output
					"void [Packet->Id]::set_[FD.id]( PacketWriter *writer, const char *src )
					"{
					"	int length = strlen( src ) + 1;
					"	long offset = writer->length();
					"	char *dest = writer->allocBytes( length );
					"	(([Packet->Id]*)writer->content)->[FD.id] = (char*)offset;
					"	memcpy( dest, src, length );
					"}
					"
			}
		}

		send Output
			"[Packet->Id] *[Packet->Id]::open( PacketWriter *writer )
			"{
			"	writer->reset();
			"
			"	/* Place the header. */
			"	PacketHeader *header = (PacketHeader*) writer->allocBytes( sizeof(PacketHeader) );
			"	
			"	header->msgId = [Packet->Id]::ID;
			"	header->writerId = 1; // writer->id;
			"
			"	/* Place the struct. */
			"	[Packet->Id] *msg = ([Packet->Id]*) writer->allocBytes( sizeof([Packet->Id]) );
			"
			"	header->length = 0;
			"	writer->toSend = header;
			"	writer->content = msg;
			"
			"	return msg;
			"}
			"

		send Output
			"void [Packet->Id]::send( PacketWriter *writer )
			"{
			"	writer->toSend->length = writer->length();
			"	for ( RopeBlock *rb = writer->buf.hblk; rb != 0; rb = rb->next )
			"		::write( writer->fd, writer->buf.data(rb), writer->buf.length(rb) );
			"}
			"
	}

	send Output [] eos

	writeOutput( Output->tree, 'packet_gen.cc' )
}
