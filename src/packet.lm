namespace packet_name
	lex
		literal `-
		token component /[A-Z][a-z]*/
	end

	def name
		[component*]
	
	str makeLower( Name: str )
	{
		Lower: str = ""
		parse PN: packet_name::name[Name]
		for C: packet_name::component in PN {
			if Lower.length > 0
				Lower = Lower + "-"
			Lower = Lower + tolower($C)
		}
		return Lower
	}
end

void definePack()
{
	send Output
		~#define _pack( type, dest, off ) \
		~	*((type*)(dest + off))
}

void generatePacketHeader( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.h
		~ */
		~
		~#ifndef __PACKET_GEN_H
		~#define __PACKET_GEN_H
		~
		~#include <sys/types.h>
		~#include <sys/socket.h>
		~#include <errno.h>
		~
		~#include <genf/packet.h>
		~#include <genf/thread.h>
		~
		~struct PacketWriter;
		~struct PacketConnection;
		~struct ItWriter;
		~

	definePack()

	#
	# Packing structs
	#

	send Output
		~namespace Packer {

	for Struct: _struct in StructMap {
		send Output
			"struct [Struct->Id]
			"{

		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`bool] {
				send Output
					"	void set_[FD.id]( long _[FD.id] )
					"		{ _pack( bool, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`int] {
				send Output
					"	void set_[FD.id]( int _[FD.id] )
					"		{ _pack( int, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`uint] {
				send Output
					"	void set_[FD.id]( unsigned int _[FD.id] )
					"		{ _pack( unsigned int, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`long] {
				send Output
					"	void set_[FD.id]( long _[FD.id] )
					"		{ _pack( long, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`ulong] {
				send Output
					"	void set_[FD.id]( unsigned long _[FD.id] )
					"		{ _pack( unsigned long, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`string] {
				send Output
					"	void set_[FD.id]( const char *s );
			}
			case [`char `( N: number `)] {
				send Output
					"	void set_[FD.id]( const char *s )
					"		{ memcpy( overlay + [FD.Offset], s, [FD.CharSize] ); }
			}
		}

		send Output
			"	char *overlay;
			"	PacketWriter *writer;
			"};
			"
	}

	for Packet: packet in PacketMap {
		send Output
			"struct [Packet->Id]
			"	: public PacketBase
			"{
			"	[Packet->Id]( PacketConnection *pc  ) : writer( pc ) { open( &writer ); }
			"	[Packet->Id]( ItWriter *itw ) : writer( itw ) { open( &writer ); }
			"	PacketWriter writer;

		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`bool] {
				send Output
					"	void set_[FD.id]( bool _[FD.id] )
					"		{ _pack( bool, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`int] {
				send Output
					"	void set_[FD.id]( int _[FD.id] )
					"		{ _pack( int, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`uint] {
				send Output
					"	void set_[FD.id]( unsigned int _[FD.id] )
					"		{ _pack( unsigned int, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`long] {
				send Output
					"	void set_[FD.id]( long _[FD.id] )
					"		{ _pack( long, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`ulong] {
				send Output
					"	void set_[FD.id]( unsigned long _[FD.id] )
					"		{ _pack( unsigned long, overlay, [FD.Offset] ) = _[FD.id]; }
			}
			case [`string] {
				send Output
					"	void set_[FD.id]( const char *d );
			}
			case [list_type] {
				TypeId: id = FD.record_field_type.list_type.id
				send Output
					"	char *tail_[FD.id];
					"	void alloc_[FD.id]( [TypeId] &el );

			}
			case [`char `( N: number `)] {
				send Output
					"	void set_[FD.id]( const char *s )
					"		{ memcpy( overlay + [FD.Offset], s, [FD.CharSize] ); }
			}
		}

		send Output
			"	void send()
			"	{
			"		PacketBase::send( &writer );
			"	}
			"	char *overlay;
			"	void open( PacketWriter *writer );
			"	static const unsigned short ID = [Packet->AppID * 1000 + Packet->NumID];
			"	static const char name\[\];
			"	static const char lower\[\];
			"};
			"
	}

	send Output
		~}
		~
	#
	# Reading structs structs
	#

	send Output
		~namespace Record {

	for Struct: _struct in StructMap {
		send Output
			"struct [Struct->Id]
			"{
			"	[Struct->Id]( Rope *rope, long offset );

		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
			}
			case [`int] {
				send Output
					"	int [FD.id];
			}
			case [`uint] {
				send Output
					"	unsigned int [FD.id];
			}
			case [`long] {
				send Output
					"	long [FD.id];
			}
			case [`ulong] {
				send Output
					"	unsigned long [FD.id];
			}
			case [`string] {
				send Output
					"	char *[FD.id];
			}
			case [`char `( N: number `)] {
				send Output
					"	char [FD.id]\[[FD.CharSize]\];
			}
		}

		send Output
			"	void advance();
			"	bool valid();
			"	void load();
			"	long next;
			"	Rope *rope;
			"	long offset;
			"};
			"
	}

	for Packet: packet in PacketMap {
		send Output
			"struct [Packet->Id]
			"	: public PacketBase
			"{
			"	[Packet->Id]( Rope *rope, long offset );

		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
			}
			case [`int] {
				send Output
					"	int [FD.id];
			}
			case [`uint] {
				send Output
					"	unsigned int [FD.id];
			}
			case [`long] {
				send Output
					"	long [FD.id];
			}
			case [`ulong] {
				send Output
					"	unsigned long [FD.id];
			}
			case [`string] {
				send Output
					"	char *[FD.id];
			}
			case [list_type] {
				TypeId: id = FD.record_field_type.list_type.id
				send Output
					"	uint32_t head_[FD.id];
			}
			case [`char `( N: number `)] {
				send Output
					"	char [FD.id]\[[FD.CharSize]\];
			}
		}

		send Output
			"	Rope *rope;
			"	static const unsigned short ID = [Packet->AppID * 1000 + Packet->NumID];
			"	static const char name\[\];
			"	static const char lower\[\];
			"};
			"
	}

	send Output
		~}
		~
		~const char *packetLowerName( unsigned short id );
		~
		~#undef _pack
		~
		~#endif
		eos

	writeOutput( Output->tree, 'packet_gen.h' )
}

void packetRecvDecls( Thread: thread )
{
	send Output
		"	virtual void dispatchPacket( SelectFd *fd, SelectFd::Recv &recv );

	for Packet: packet in Thread->RecvsPktList {
		send Output
			"	virtual void recv[Packet->Id]( SelectFd *fd, Record::[Packet->Id] *pkt ) = 0;
	}
}

void packetReceives( Thread: thread )
{
	send Output
		"void [Thread->Id]Gen::dispatchPacket( SelectFd *fd, SelectFd::Recv &recv )
		"{
		"		switch ( recv.head->msgId ) {

	for Packet: packet in Thread->RecvsPktList {
		send Output
			"			case (int) Record::[Packet->Id]::ID: {
			"				Record::[Packet->Id] rec( &recv.buf,
			"					sizeof(PacketBlockHeader) + sizeof(PacketHeader) );
			"				recv[Packet->Id]( fd, &rec );
			"				break;
			"			}
	}

	send Output
		"		}
		"}
		"
		"
}

void generatePacketCode( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.cc
		~ */
		~
		~#include "itq_gen.h"
		~#include "packet_gen.h"
		~#include <genf/thread.h>
		~

	definePack()

	for Struct: _struct in StructMap {
		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`string] {
				send Output
					"void Packer::[Struct->Id]::set_[FD.id]( const char *src )
					"{
					"	int length = strlen( src ) + 1;
					"	uint32_t offset = 0;
					"	char *dest = writer->allocBytes( length, offset );
					"	_pack( uint32_t, overlay, [FD.Offset] ) = offset;
					"	memcpy( dest, src, length );
					"}
					"
			}
		}
	}

	for Packet: packet in PacketMap {
		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`string] {
				send Output
					"void Packer::[Packet->Id]::set_[FD.id]( const char *src )
					"{
					"	int length = strlen( src ) + 1;
					"	uint32_t offset = 0;
					"	char *dest = writer.allocBytes( length, offset );
					"	_pack( uint32_t, overlay, [FD.Offset] ) = offset;
					"	memcpy( dest, src, length );
					"}
					"
			}
			case [L: list_type] {
				TypeId: id = L.id
				El: _struct = findStruct( TypeId )
				send Output
					"void Packer::[Packet->Id]::alloc_[FD.id]( [TypeId] &el )
					"{
					"	uint32_t offset = 0;
					"	char *elov = (char*)writer.allocBytes( [El->Size], offset );
					"	memset( elov, 0, [El->Size] );
					"	
					"	uint32_t head = _pack( uint32_t, overlay, [FD.Offset] );
					"	if ( head == 0 )
					"		_pack( uint32_t, overlay, [FD.Offset] ) = offset;
					"	else
					"		_pack( uint32_t, tail_[FD.id], [El->NextOffset] ) = offset;
					"
					"	tail_[FD.id] = elov;
					"	el.overlay = elov;
					"	el.writer = &writer;
					"}
					"
			}
		}

		send Output
			"void Packer::[Packet->Id]::open( PacketWriter *writer )
			"{
			"	this->overlay = (char*)
			"			PacketBase::open( writer, [Packet->Id]::ID,
			"			[Packet->Size] );
			"}
			"

		Lower: str = packet_name::makeLower( Packet->Id )
		send Output
			"const char Packer::[Packet->Id]::name\[\] = \"[Packet->Id]\";
			"const char Packer::[Packet->Id]::lower\[\] = \"[Lower]\";
			"

	}

	for Struct: _struct in StructMap {
		send Output
			"Record::[Struct->Id]::[Struct->Id]( Rope *rope, long offset )
			"	: rope(rope), offset(offset) 
			"{
			"	if ( offset != 0 )
			"		load();
			"}
			"
			"void Record::[Struct->Id]::advance()
			"{
			"	offset = next;
			"	if ( offset != 0 )
			"		load();
			"}
			"
			"bool Record::[Struct->Id]::valid()
			"{
			"	return offset != 0;
			"}
			"
			"void Record::[Struct->Id]::load()
			"{
			"	char *overlay = Thread::pktFind( rope, offset );;

		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`bool] {
				send Output
					"	this->[FD.id] = _pack( bool, overlay, [FD.Offset] );
			}
			case [`int] {
				send Output
					"	this->[FD.id] = _pack( int, overlay, [FD.Offset] );
			}
			case [`uint] {
				send Output
					"	this->[FD.id] = _pack( unsigned int, overlay, [FD.Offset] );
			}
			case [`long] {
				send Output
					"	this->[FD.id] = _pack( long, overlay, [FD.Offset] );
			}
			case [`ulong] {
				send Output
					"	this->[FD.id] = _pack( unsigned long, overlay, [FD.Offset] );
			}
			case [`string] {
				send Output
					"	this->[FD.id] = Thread::pktFind( rope,
					"		_pack( uint32_t, overlay, [FD.Offset] ) );
			}
			case [`char `( N: number `)] {
				send Output
					"	memcpy( this->[FD.id], overlay + [FD.Offset], [FD.CharSize] );
			}
		}

		send Output
			"	this->next = _pack( uint32_t, overlay, [Struct->NextOffset] );
			"}
	}

	for Packet: packet in PacketMap {
		send Output
			"Record::[Packet->Id]::[Packet->Id]( Rope *rope, long offset )
			"{
			"	this->rope = rope;
			"	char *overlay = Thread::pktFind( rope, offset );;

			
		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`bool] {
				send Output
					"	this->[FD.id] = _pack( bool, overlay, [FD.Offset] );
			}
			case [`int] {
				send Output
					"	this->[FD.id] = _pack( int, overlay, [FD.Offset] );
			}
			case [`uint] {
				send Output
					"	this->[FD.id] = _pack( int, overlay, [FD.Offset] );
			}
			case [`long] {
				send Output
					"	this->[FD.id] = _pack( long, overlay, [FD.Offset] );
			}
			case [`ulong] {
				send Output
					"	this->[FD.id] = _pack( long, overlay, [FD.Offset] );
			}
			case [`string] {
				send Output
					"	this->[FD.id] = Thread::pktFind( rope,
					"		_pack( uint32_t, overlay, [FD.Offset] ) );
			}
			case [L: list_type] {
				TypeId: id = L.id
				send Output
					"	this->head_[FD.id] = _pack( uint32_t, overlay, [FD.Offset] );

			}
		}

		send Output
			"}

		Lower: str = packet_name::makeLower( Packet->Id )
		send Output
			"const char Record::[Packet->Id]::name\[\] = \"[Packet->Id]\";
			"const char Record::[Packet->Id]::lower\[\] = \"[Lower]\";
			"

	}

	send Output
		"const char *packetLowerName( unsigned short id )
		"{
		"	switch ( id ) {

	for Packet: packet in PacketMap {
		send Output
		"		case Record::[Packet->Id]::ID: return Record::[Packet->Id]::lower;
	}

	send Output
		"	}
		"	return \"unknown\";
		"}

	send Output [] eos

	writeOutput( Output->tree, 'packet_gen.cc' )
}

void generateJava( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * BrokerGen.java
		~ */
		~
		~package net.colm.monitor;
		~
		~import java.io.InputStream;
		~import java.io.OutputStream;
		~import java.io.UnsupportedEncodingException;
		~import java.nio.ByteBuffer;
		~import java.nio.ByteOrder;
		~import java.io.IOException;
		~import java.util.Iterator;
		~import java.util.Arrays;
		~
		~abstract public class BrokerGen
		~	extends BrokerBase
		~{

	for Packet: packet in PacketMap {
		send Output
			"	void send[Packet->Id]( "

		Comma: str = ""
		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`bool] {
				send Output "[Comma]boolean [FD.id]"
			}
			case [`int] {
				send Output "[Comma]int [FD.id]"
			}
			case [`uint] {
				send Output "[Comma]int [FD.id]"
			}
			case [`long] {
				send Output "[Comma]long [FD.id]"
			}
			case [`ulong] {
				send Output "[Comma]long [FD.id]"
			}
			case [`string] {
				send Output "[Comma]String [FD.id]"
			}
			case [L: list_type] { }
			case [`char `( N: number `)] { }
			Comma = ", "
		}
			
		send Output " )
			"	{
			"		byte\[\] b = new byte\[[16 + Packet->Size]\];
			"		ByteBuffer bbb = ByteBuffer.wrap(b);
			"		bbb.order( ByteOrder.LITTLE_ENDIAN );
			"
			"		/* Next block length, id, total length, first length */
			"		bbb.putInt( 0,  0 );
			"		bbb.putInt( 4,  [Packet->Id].ID );
			"		bbb.putInt( 8,  [16 + Packet->Size] );
			"		bbb.putInt( 12, [16 + Packet->Size] );
			"

		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`bool] {
				send Output "		bbb.putByte( [16 + FD.Offset], [FD.id] );
			}
			case [`int] {
				send Output "		bbb.putInt( [16 + FD.Offset], [FD.id] );
			}
			case [`uint] {
				send Output "		bbb.putInt( [16 + FD.Offset], [FD.id] );
			}
			case [`long] {
				send Output "		bbb.putLong( [16 + FD.Offset], [FD.id] );
			}
			case [`ulong] {
				send Output "		bbb.putLong( [16 + FD.Offset], [FD.id] );
			}
			case [`string] {
			}
			case [L: list_type] { }
			case [`char `( N: number `)] { }
		}

		send Output
			"		OutputStream output = null;
			"		try {
			"			output = socket.getOutputStream();
			"			output.write( b );
			"		}
			"		catch ( IOException e ) {
			"			e.printStackTrace();
			"		}
			"	}
	}

	for Struct: _struct in StructMap {
		send Output
			"public static class [Struct->Id]
			"{
			"	public [Struct->Id]( Packet packet, int offset )
			"	{
			"		this.packet = packet;
			"		this.offset = offset;
			"		if ( offset != 0 )
			"			load();
			"	}

		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`bool] {
				send Output
					"	public byte [FD.id];
			}
			case [`int] {
				send Output
					"	public int [FD.id];
			}
			case [`uint] {
				send Output
					"	public int [FD.id];
			}
			case [`long] {
				send Output
					"	public long [FD.id];
			}
			case [`ulong] {
				send Output
					"	public long [FD.id];
			}
			case [`string] {
				send Output
					"	public String [FD.id];
			}
			case [`char `( N: number `)] {
				send Output
					"	public byte\[\] [FD.id];
			}
		}

		send Output
			"	int next;
			"	Packet packet;
			"	int offset;

		send Output
			"public void advance()
			"{
			"	offset = next;
			"	if ( offset != 0 )
			"		load();
			"}
			"
			"public boolean valid()
			"{
			"	return offset != 0;
			"}
			"

		send Output
			"void load()
			"{
			"	int len;
			"	int stroff;
			"	PacketPos strPos;
			"	PacketPos recordPos = pktFind( this.packet, this.offset );
			"	

		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`bool] {
				send Output
					"	this.[FD.id] = recordPos.element\[[FD.Offset]\];
			}
			case [`int] {
				send Output
					"	this.[FD.id] = recordPos.block.getInt( recordPos.offset + [FD.Offset] );
			}
			case [`uint] {
				send Output
					"	this.[FD.id] = recordPos.block.getInt( recordPos.offset + [FD.Offset] );
			}
			case [`long] {
				send Output
					"	this.[FD.id] = recordPos.block.getLong( recordPos.offset + [FD.Offset] );
			}
			case [`ulong] {
				send Output
					"	this.[FD.id] = recordPos.block.getLong( recordPos.offset + [FD.Offset] );
			}
			case [`string] {
				send Output
					"	stroff = recordPos.block.getInt( recordPos.offset + [FD.Offset] );
					"	strPos = pktFind( packet, stroff );
					"	len = packetStrLen( strPos );
					"	try {
					"		this.[FD.id] = new String( strPos.element,
					"				strPos.offset, len, \"ASCII\" );
					"	}
					"	catch ( UnsupportedEncodingException e )
					"	{
					"		e.printStackTrace();
					"	}
			}
			case [`char `( N: number `)] {
				send Output
					"	this.[FD.id] = Arrays.copyOfRange( recordPos.element,
					"		recordPos.offset + [FD.Offset],
					"		recordPos.offset + [FD.Offset] + [N] );
			}
		}

		send Output
			"	this.next = recordPos.block.getInt( recordPos.offset + [Struct->NextOffset] );
			"}
			"

		send Output
			"}
	}

	for Packet: packet in PacketMap {
		send Output
			"public static class [Packet->Id]
			"{

		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`bool] {
				send Output
					"	public boolean [FD.id];
			}
			case [`int] {
				send Output
					"	public int [FD.id];
			}
			case [`uint] {
				send Output
					"	public int [FD.id];
			}
			case [`long] {
				send Output
					"	public long [FD.id];
			}
			case [`ulong] {
				send Output
					"	public long [FD.id];
			}
			case [`string] {
				send Output
					"	public String [FD.id];
			}
			case [L: list_type] {
				send Output
					"	public int [FD.id];
			}
			case [`char `( N: number `)] {
				send Output
					"	public byte\[\] [FD.id];
			}
		}

		send Output
			"	public Packet packet;

		send Output
			"void read( Packet packet, int offset )
			"{
			"	int len;
			"	int stroff;
			"	PacketPos strPos;
			"	PacketPos recordPos = pktFind( packet, offset );
			"	this.packet = packet;
			"	

		for FD: record_field_def in Packet->PacketDef {
			switch FD.record_field_type
			case [`bool] {
				send Output
					"	this.[FD.id] = recordPos.block.getByte( recordPos.offset + [FD.Offset] );
			}
			case [`int] {
				send Output
					"	this.[FD.id] = recordPos.block.getInt( recordPos.offset + [FD.Offset] );
			}
			case [`uint] {
				send Output
					"	this.[FD.id] = recordPos.block.getInt( recordPos.offset + [FD.Offset] );
			}
			case [`long] {
				send Output
					"	this.[FD.id] = recordPos.block.getLong( recordPos.offset + [FD.Offset] );
			}
			case [`ulong] {
				send Output
					"	this.[FD.id] = recordPos.block.getLong( recordPos.offset + [FD.Offset] );
			}
			case [`string] {
				send Output
					"	stroff = recordPos.block.getInt( recordPos.offset + [FD.Offset] );
					"	strPos = pktFind( packet, stroff );
					"	len = packetStrLen( strPos );
					"	try {
					"		this.[FD.id] = new String( strPos.element, strPos.offset, len, \"ASCII\" );
					"	}
					"	catch ( UnsupportedEncodingException e )
					"	{
					"		e.printStackTrace();
					"	}
			}
			case [`char `( N: number `)] {
				send Output
					"	this.[FD.id] = Arrays.copyOfRange( recordPos.element,
					"		recordPos.offset + [FD.Offset],
					"		recordPos.offset + [FD.Offset] + [N] );
			}
			case [L: list_type] {
				send Output
					"	this.[FD.id] = recordPos.block.getInt( recordPos.offset + [FD.Offset] );
			}
		}

		send Output
			"}

		send Output
			"	static final int ID = [Packet->AppID * 1000 + Packet->NumID];
			"}
	}

	
	for Struct: _struct in StructMap {

	}

	for Packet: packet in PacketMap {
	}

	send Output
		~	void dispatch( Packet packet )
		~	{
		~		// Log.i( LOG_TAG, "dispatching packet parsing packet" );
		~		// System.out.println( packet.totalLen );
		~
		~		switch ( packet.msgId ) {

	for Packet: packet in PacketMap {
		send Output
			"		case [Packet->Id].ID: {
			"			[Packet->Id] p = new [Packet->Id]();
			"			p.read( packet, 16 );
			
		if ( Packet->Id == "MonitorDisp" ) {
			send Output
				"			callback.received( p.content );
		}

		if ( Packet->Id == "QuoteList" ) {
			send Output
				"			callback.received( p );
		}

		send Output
			"			break;
			"		}
	}

	send Output
		~		}
		~	}
		~}

	send Output [] eos

	writeOutput( Output->tree, 'BrokerGen.java' )
}
