namespace packet_name
	lex
		literal `-
		token component /[A-Z][a-z]*/
	end

	def name
		[component*]
	
	str makeLower( Name: str )
	{
		Lower: str = ""
		parse PN: packet_name::name[Name]
		for C: packet_name::component in PN {
			if Lower.length > 0
				Lower = Lower + "-"
			Lower = Lower + tolower($C)
		}
		return Lower
	}

end

void generatePacketHeader( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.h
		~ */
		~
		~#ifndef __PACKET_GEN_H
		~#define __PACKET_GEN_H
		~
		~#include <sys/types.h>
		~#include <sys/socket.h>
		~#include <errno.h>
		~
		~#include <genf/packet.h>
		~
		~struct PacketWriter;
		~
		~namespace Packer {

	for Struct: _struct in StructMap {
		send Output
			"struct [Struct->Id]
			"{

		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
					"	void set_[FD.id]( long _[FD.id] ) { [FD.id] = _[FD.id]; }
			}
			case [`long] {
				send Output
					"	long [FD.id];
					"	void set_[FD.id]( long _[FD.id] ) { [FD.id] = _[FD.id]; }
			}
			case [`string] {
				send Output
					"	char *[FD.id];
					"	void set_[FD.id]( PacketWriter *writer, const char *d );
			}
		}

		send Output
			"	[Struct->Id] *next;
			"};
			"
	}

	for Packet: packet in PacketMap {
		send Output
			"struct [Packet->Id]
			"	: public PacketBase
			"{

		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
					"	void set_[FD.id]( long _[FD.id] ) { [FD.id] = _[FD.id]; }
			}
			case [`long] {
				send Output
					"	long [FD.id];
					"	void set_[FD.id]( long _[FD.id] ) { [FD.id] = _[FD.id]; }
			}
			case [`string] {
				send Output
					"	char *[FD.id];
					"	void set_[FD.id]( PacketWriter *writer, const char *d );
			}
			case [list_type] {
				TypeId: id = FD.pkt_field_type.list_type.id
				send Output
					"	[TypeId] *head_[FD.id];
					"	[TypeId] *tail_[FD.id];
					"	[TypeId] *alloc_[FD.id]( PacketWriter *writer, [Packet->Id] *pkt );

			}
		}

		send Output
			"	static [Packet->Id] *open( PacketWriter *writer );
			"	static const unsigned short ID = [Packet->AppID * 1000 + Packet->NumID];
			"	static const char name\[\];
			"	static const char lower\[\];
			"};
			"
	}

	send Output
		~}
		~
		~namespace Record {
		~

	for Struct: _struct in StructMap {
		send Output
			"struct [Struct->Id]
			"{

		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
			}
			case [`long] {
				send Output
					"	long [FD.id];
			}
			case [`string] {
				send Output
					"	char *[FD.id];
			}
		}

		send Output
			"	[Struct->Id] *next;
			"};
			"
	}

	for Packet: packet in PacketMap {
		send Output
			"struct [Packet->Id]
			"	: public PacketBase
			"{

		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`bool] {
				send Output
					"	bool [FD.id];
			}
			case [`long] {
				send Output
					"	long [FD.id];
			}
			case [`string] {
				send Output
					"	char *[FD.id];
			}
			case [list_type] {
				TypeId: id = FD.pkt_field_type.list_type.id
				send Output
					"	[TypeId] *head_[FD.id];
					"	[TypeId] *tail_[FD.id];

			}
		}

		send Output
			"	static const unsigned short ID = [Packet->AppID * 1000 + Packet->NumID];
			"	static const char name\[\];
			"	static const char lower\[\];
			"};
			"
	}

	send Output
		~}
		~
		~const char *packetLowerName( unsigned short id );
		~
		~#endif
		eos

	writeOutput( Output->tree, 'packet_gen.h' )
}

void packetRecvDecls( Thread: thread )
{
	send Output
		"	virtual void dispatchPacket( SelectFd *fd, SelectFd::Recv &recv );

	for Packet: packet in Thread->RecvsPktList {
		send Output
			"	virtual void recv[Packet->Id]( SelectFd *fd, Record::[Packet->Id] *pkt ) = 0;
	}
}

void packetReceives( Thread: thread )
{
	send Output
		"void [Thread->Id]Gen::dispatchPacket( SelectFd *fd, SelectFd::Recv &recv )
		"{
		"		switch ( recv.head->msgId ) {

	for Packet: packet in Thread->RecvsPktList {
		send Output
			"			case (int) Record::[Packet->Id]::ID: {
			"			Record::[Packet->Id] *pkt = (Record::[Packet->Id]*) pktFind( 
			"					&recv.buf, sizeof(PacketBlockHeader) + sizeof(PacketHeader) );


		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`string] {
				send Output
					"			pkt->[FD.id] = pktFind( &recv.buf, (long)pkt->[FD.id] );
			}
			case [L: list_type] {
				TypeId: id = L.id
				send Output
					"			pkt->head_[FD.id] = (Record::[TypeId]*)pktFind( &recv.buf,
					"					(long)pkt->head_[FD.id] );
					"			Record::[TypeId] *el = pkt->head_[FD.id];
					"			while ( el != 0 ) {

				Struct: _struct = findStruct( TypeId )
				for SFD: struct_field_def in Struct->StructDef {
					switch SFD.struct_field_type
					case [`string] {
						send Output
							"			el->[SFD.id] = pktFind( &recv.buf,
							"					(long)el->[SFD.id] );
					}
				}

				send Output
					"				el->next = (Record::[TypeId]*)pktFind( &recv.buf,
					"						(long)el->next );
					"				el = el->next;
					"			}
			}
		}

		send Output
			"				recv[Packet->Id]( fd, pkt );
			"				break;
			"			}
	}

	send Output
		"		}
		"}
		"
		"
}




void generatePacketCode( P: program )
{
	Output = new parser<out_c::out_c>()

	send Output
		~/*
		~ * packet_gen.cc
		~ */
		~
		~#include "itq_gen.h"
		~#include "packet_gen.h"
		~#include <genf/thread.h>
		~

	for Struct: _struct in StructMap {
		for FD: struct_field_def in Struct->StructDef {
			switch FD.struct_field_type
			case [`string] {
				send Output
					"void Packer::[Struct->Id]::set_[FD.id]( PacketWriter *writer, const char *src )
					"{
					"	int length = strlen( src ) + 1;
					"	long offset = 0;
					"	char *dest = writer->allocBytes( length, offset );
					"	[FD.id] = (char*)offset;
					"	memcpy( dest, src, length );
					"}
					"
			}
		}
	}

	for Packet: packet in PacketMap {
		for FD: pkt_field_def in Packet->PacketDef {
			switch FD.pkt_field_type
			case [`string] {
				send Output
					"void Packer::[Packet->Id]::set_[FD.id]( PacketWriter *writer, const char *src )
					"{
					"	int length = strlen( src ) + 1;
					"	long offset = 0;
					"	char *dest = writer->allocBytes( length, offset );
					"	(([Packet->Id]*)writer->content)->[FD.id] = (char*)offset;
					"	memcpy( dest, src, length );
					"}
					"
			}
			case [L: list_type] {
				TypeId: id = L.id
				send Output
					"Packer::[TypeId] *Packer::[Packet->Id]::alloc_[FD.id]( PacketWriter *writer, [Packet->Id] *pkt )
					"{
					"	long offset = 0;
					"	[TypeId] *el = ([TypeId]*)writer->allocBytes( sizeof([TypeId]), offset );
					"	memset( el, 0, sizeof([TypeId]) );
					"	
					"	el->next = 0;
					"
					"	if ( pkt->head_[FD.id] == 0 )
					"		pkt->head_[FD.id] = ([TypeId]*)offset;
					"	else
					"		pkt->tail_[FD.id]->next = ([TypeId]*)offset;
					"
					"	pkt->tail_[FD.id] = el;
					"
					"	return el;
					"}
					"
			}
		}

		send Output
			"Packer::[Packet->Id] *Packer::[Packet->Id]::open( PacketWriter *writer )
			"{
			"	return ([Packet->Id]*) PacketBase::open( writer,
			"		[Packet->Id]::ID, sizeof([Packet->Id]) );
			"}
			"

		Lower: str = packet_name::makeLower( Packet->Id )
		send Output
			"const char Packer::[Packet->Id]::name\[\] = \"[Packet->Id]\";
			"const char Packer::[Packet->Id]::lower\[\] = \"[Lower]\";
			"

	}


	for Packet: packet in PacketMap {
		Lower: str = packet_name::makeLower( Packet->Id )
		send Output
			"const char Record::[Packet->Id]::name\[\] = \"[Packet->Id]\";
			"const char Record::[Packet->Id]::lower\[\] = \"[Lower]\";
			"

	}

	send Output
		"const char *packetLowerName( unsigned short id )
		"{
		"	switch ( id ) {

	for Packet: packet in PacketMap {
		send Output
		"		case Record::[Packet->Id]::ID: return Record::[Packet->Id]::lower;
	}

	send Output
		"	}
		"	return \"unknown\";
		"}

	send Output [] eos

	writeOutput( Output->tree, 'packet_gen.cc' )
}
