void sendsToDecls( Thread: thread )
{
	for Sends: sends in Thread->SendsMap {
		send Output
			"struct SendsTo[Sends->Receiver->Id]
			"{
			"	ItWriter *writer;

		for Message: message in Sends->MessageList {
			send Output
				"	[Message->Id] *open[Message->Id]()
				"		{ return [Message->Id]::open( writer ); }
		}

		send Output
			"	void send() { writer->queue->send( writer ); }
			"};
			"
			"SendsTo[Sends->Receiver->Id] *registerSendsTo[Sends->Receiver->Id](
			"		[Sends->Receiver->Id]Thread *recv );
	}
}

void recvDecls( Thread: thread )
{
	for Message: message in Thread->RecvsList {
		send Output
			"	virtual void recv[Message->Id]( [Message->Id] * ) = 0;
	}
}

void sendsToCode( Thread: thread )
{
	for Sends: sends in Thread->SendsMap {
		send Output
			"[Thread->Id]Thread::SendsTo[Sends->Receiver->Id] *[Thread->Id]Gen::"
					"registerSendsTo[Sends->Receiver->Id]( "
					"[Sends->Receiver->Id]Thread *recv )
			"{
			"	SendsTo[Sends->Receiver->Id] *sendsTo = 
			"		new SendsTo[Sends->Receiver->Id]( );
			"	sendsTo->writer = recv->control.registerWriter( this, recv );
			"	return sendsTo;
			"}
	}
}

void generateThreadHeader( Thread: thread )
{
	Output = new parser<out_c::out_c>()

	send Output
		"/*
		" * [Thread->Lower]_gen.h
		" */
		"
		"#ifndef _[Thread->Upper]_GEN_H
		"#define _[Thread->Upper]_GEN_H
		"

	send Output
		~#include <genf/thread.h>
		~#include "itq_gen.h"
		~

	threadForwards( Thread )

	send Output
		"struct [Thread->Id]Gen
		"	: public Thread
		"{
		"	[Thread->Id]Gen() : Thread( \"[Thread->Lower]\" ) {}
		"
		"	void init() { }
		"	int start();
		"	void join();
		"	virtual int main() { return 0; }
		"	void recvHeader( ItQueue *queue, ItHeader *header );
		"
		"	int recv();
		"	int poll();
		"	virtual void data( SelectFd *fd );
		"	void close( SelectFd *fd );
		"

	createChildDecls( Thread )
	sendsToDecls( Thread )
	recvDecls( Thread )

	send Output
		"};
		"#endif

	send Output [] eos
	writeOutput( Output->tree, "[Thread->Lower]_gen.h" )
}

void createChildDecls( Thread: thread )
{
	for Child: thread in Thread->Starts {
		send Output
			"	void create( [Child->Id]Thread *child );
	}
	send Output "
}

void createChildDefs( Thread: thread )
{
	for Child: thread in Thread->Starts {
		send Output
			"void [Thread->Id]Gen::create( [Child->Id]Thread *child )
			"{
			"	childList.append( child );
			"	pthread_create( &child->pthread, 0, thread_start_routine, child );
			"}
			"
	}
}

void joinDef( Thread: thread )
{
	send Output
		"void [Thread->Id]Gen::join()
		"{
		"	for ( Thread *child = childList.head;
		"			child != 0; child = child->next )
		"	{
		"		int res = pthread_join( child->pthread, 0 );
		"		if ( res != 0 ) {
		"			log_ERROR( \"join with child failed: strerrno(res)\" );
		"		}
		"	}
		"}
}

void threadIncludes( Thread: thread )
{
	for Child: thread in Thread->Starts {
		send Output
			"#include \"[Child->Lower].h\"
	}

	for Sends: sends in Thread->SendsMap {
		send Output
			"#include \"[Sends->Receiver->Lower].h\"
	}

	send Output "
}

void threadForwards( Thread: thread )
{
	for Child: thread in Thread->Starts {
		send Output
			"struct [Child->Id]Gen;
			"struct [Child->Id]Thread;
	}

	for Sends: sends in Thread->SendsMap {
		for Message: message in Sends->MessageList {
			send Output
				"struct [Message->Id];
		}
	}

	send Output "
}


void generatePacketReceives( Thread: thread )
{
	send Output
		"#include \"packet_gen.h\"
		"
		"void [Thread->Id]Gen::data( SelectFd *fd )
		"{
		"	log_message( \"select in data call\" );
		"	PacketHeader packetHeader;
		"	int len = read( fd->fd, &packetHeader, sizeof(packetHeader) );
		"	log_message( \"header read: \" << len );
		"	if ( len == 0 ) {
		"		close( fd );
		"		return;
		"	}
		"
		"	switch ( packetHeader.msgId )  {
		"		case (int) StatsQuery::ID: {
		"			StatsQuery sq;
		"			len = read( fd->fd, &sq, sizeof(sq) );
		"			if ( len == 0 ) {
		"				close( fd );
		"				return;
		"			}
		"			log_message( \"received StatsQuery\" );
		"			break;
		"		}
		"	}
		"}
		"
		"void [Thread->Id]Gen::close( SelectFd *fd )
		"{
		"	log_message( \"closing: \" << fd->fd );
		"	::close( fd->fd );
		"	selectFdList.detach( fd );
		"	delete fd;
		"}   
		"
}


void generateThreadCode( Thread: thread )
{
	Output = new parser<out_c::out_c>()

	send Output
		"/*
		" * [Thread->Lower]_gen.cc
		" */
		"

	send Output
		"#include \"[Thread->Lower].h\"

	threadIncludes( Thread )
	threadForwards( Thread )

	send Output ~

	createChildDefs( Thread )
	joinDef( Thread )
	sendsToCode( Thread )

	generatePacketReceives( Thread )

	send Output
		"int [Thread->Id]Gen::start()
		"{
		"	return main();
		"};
		"

	send Output
		"void [Thread->Id]Gen::recvHeader( ItQueue *queue, ItHeader *header )
		"{
		"	switch ( header->msgId ) {

	for Message: message in Thread->RecvsList {
		send Output
			"		case [Message->Id]::ID: {
			"			[Message->Id] *msg = [Message->Id]::read( queue, header );
			"			recv[Message->Id]( msg );
			"			break;
			"		}
	}

	send Output
		"	}
		"}
		"
	
	send Output
		"int [Thread->Id]Gen::recv()
		"{
		"	breakLoop = false;
		"	while ( !breakLoop ) {
		"		ItHeader *header = control.wait();
		"		recvHeader( &control, header );
		"		control.release( header );
		"	}
		"	return 0;
		"}
		"

	send Output
		"int [Thread->Id]Gen::poll()
		"{
		"	if ( control.poll() ) {
		"		ItHeader *header = control.wait();
		"		recvHeader( &control, header );
		"		control.release( header );
		"	}
		"	return 0;
		"}
		"

	send Output [] eos
	writeOutput( Output->tree, "[Thread->Lower]_gen.cc" )
}
