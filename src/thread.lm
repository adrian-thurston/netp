def thread
	Id: str
	Lower: str
	Upper: str
	Starts: list2<ptr<thread>>
	StartedBy: ptr<thread>
	SendsMap: map2<ptr<thread> ptr<sends>>
	RecvsList: list2<ptr<message>>
	[]

def message
	Id: str
	MessageDef: message_def
	[]

def sends
	Sender: ptr<thread>
	Receiver: ptr<thread>
	MessageList: list2<ptr<message>>
	[]

global ThreadMap: map2<str ptr<thread>> = new2 map2<str ptr<thread>>
global MessageMap: map2<str ptr<message>> = new2 map2<str ptr<message>>

#
# Thread map.
#
ptr<thread> findThread( Id: id )
{
	Thread: ptr<thread> = ThreadMap->find( $Id )
	if ! Thread {
		send stderr "inp:[Id.line]: failed to locate thread [Id]
		exit( 1 )
	}
	return Thread
}

ptr<thread> consThread( ThreadDef: thread_def )
{
	Thread: ptr<thread> = new cons thread( $ThreadDef.id )[]
	Thread->Lower = tolower( Thread->Id )
	Thread->Upper = toupper( Thread->Id )
	Thread->Starts = new2 list2<ptr<thread>>
	Thread->SendsMap = new2 map2<ptr<thread> ptr<sends>>
	Thread->RecvsList = new2 list2<ptr<message>>
	return Thread
}

#
# Message map.
#
ptr<message> findMessage( Id: id )
{
	Message: ptr<message> = MessageMap->find( $Id )
	if ! Message {
		send stderr "inp:[Id.line]: failed to locate message [Id]
		exit( 1 )
	}
	return Message
}

ptr<message> consMessage( MessageDef: message_def )
{
	Message: ptr<message> = new cons message( $MessageDef.id )[]
	Message->MessageDef = MessageDef
	return Message
}

void sendsToDecls( Thread: ptr<thread> )
{
	for Sends: ptr<sends> in deref Thread->SendsMap {
		send Output
			"struct SendsTo[Sends->Receiver->Id]
			"{
			"	ItWriter *writer;

		for Message: ptr<message> in deref Sends->MessageList {
			send Output
				"	[Message->Id] *open[Message->Id]()
				"		{ return [Message->Id]::open( writer ); }
		}

		send Output
			"	void send() { writer->queue->send( writer ); }
			"};
			"
			"SendsTo[Sends->Receiver->Id] *registerSendsTo[Sends->Receiver->Id](
			"		[Sends->Receiver->Id]Thread *recv );
	}
}

void recvDecls( Thread: ptr<thread> )
{
	for Message: ptr<message> in deref Thread->RecvsList {
		send Output
			"	virtual void recv[Message->Id]( [Message->Id] * ) = 0;
	}
}

void sendsToCode( Thread: ptr<thread> )
{
	for Sends: ptr<sends> in deref Thread->SendsMap {
		send Output
			"[Thread->Id]Thread::SendsTo[Sends->Receiver->Id] *[Thread->Id]Gen::"
					"registerSendsTo[Sends->Receiver->Id]( "
					"[Sends->Receiver->Id]Thread *recv )
			"{
			"	SendsTo[Sends->Receiver->Id] *sendsTo = 
			"		new SendsTo[Sends->Receiver->Id]( );
			"	sendsTo->writer = recv->control.registerWriter( this );
			"	return sendsTo;
			"}
	}
}

void generateThreadHeader( Thread: ptr<thread> )
{
	Output = cons parser<out_c::out_c>[]

	send Output
		"/*
		" * [Thread->Lower]_gen.h
		" */
		"
		"#ifndef _[Thread->Upper]_GEN_H
		"#define _[Thread->Upper]_GEN_H
		"

	send Output
		~#include "thread.h"
		~#include "itq_gen.h"
		~

	threadForwards( Thread )

	send Output
		"struct [Thread->Id]Gen
		"	: public Thread
		"{
		"	[Thread->Id]Gen() : Thread( \"[Thread->Lower]\" ) {}
		"
		"	void init() { }
		"	int start();
		"	void join();
		"	virtual int main() { return 0; }
		"	bool breakRecv;
		"	int recv();
		"

	createChildDecls( Thread )
	sendsToDecls( Thread )
	recvDecls( Thread )

	send Output
		"};
		"#endif

	send Output [] eos
	writeOutput( Output.tree "[Thread->Lower]_gen.h" )
}

void createChildDecls( Thread: ptr<thread> )
{
	for Child: ptr<thread> in deref Thread->Starts {
		send Output
			"	void create( [Child->Id]Thread *child );
	}
	send Output "
}

void createChildDefs( Thread: ptr<thread> )
{
	for Child: ptr<thread> in deref Thread->Starts {
		send Output
			"void [Thread->Id]Gen::create( [Child->Id]Thread *child )
			"{
			"	childList.append( child );
			"	pthread_create( &child->pthread, 0, thread_start_routine, child );
			"}
			"
	}
}

void joinDef( Thread: ptr<thread> )
{
	send Output
		"void [Thread->Id]Gen::join()
		"{
		"	for ( Thread *child = childList.head;
		"			child != 0; child = child->next )
		"	{
		"		int res = pthread_join( child->pthread, 0 );
		"		if ( res != 0 ) {
		"			log_ERROR( \"join with child failed: strerrno(res)\" );
		"		}
		"	}
		"}
}

void threadIncludes( Thread: ptr<thread> )
{
	for Child: ptr<thread> in deref Thread->Starts {
		send Output
			"#include \"[Child->Lower].h\"
	}

	for Sends: ptr<sends> in deref Thread->SendsMap {
		send Output
			"#include \"[Sends->Receiver->Lower].h\"
	}

	send Output "
}

void threadForwards( Thread: ptr<thread> )
{
	for Child: ptr<thread> in deref Thread->Starts {
		send Output
			"struct [Child->Id]Gen;
			"struct [Child->Id]Thread;
	}

	for Sends: ptr<sends> in deref Thread->SendsMap {
		for Message: ptr<message> in deref Sends->MessageList {
			send Output
				"struct [Message->Id];
		}
	}

	send Output "
}

void generateThreadCode( Thread: ptr<thread> )
{
	Output = cons parser<out_c::out_c>[]

	send Output
		"/*
		" * [Thread->Lower]_gen.cc
		" */
		"

	send Output
		"#include \"[Thread->Lower].h\"

	threadIncludes( Thread )
	threadForwards( Thread )

	send Output ~

	createChildDefs( Thread )
	joinDef( Thread )
	sendsToCode( Thread )

	send Output
		"int [Thread->Id]Gen::start()
		"{
		"	return main();
		"};
		"
	
	send Output
		"int [Thread->Id]Gen::recv()
		"{
		"	breakRecv = false;
		"	while ( !breakRecv ) {
		"		ItHeader *header = control.wait();
		"		switch ( header->msgId ) {

	for Message: ptr<message> in deref Thread->RecvsList {
		send Output
			"			case [Message->Id]::ID: {
			"				[Message->Id] *msg = [Message->Id]::read( &control, header );
			"				recv[Message->Id]( msg );
			"				break;
			"			}
	}

	send Output
		"		}
		"		control.release( header );
		"	}
		"	return 0;
		"}

	send Output [] eos
	writeOutput( Output.tree "[Thread->Lower]_gen.cc" )
}
