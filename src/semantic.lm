
global ModuleName: id
global RootKobj: ptr<kobj>

void semanticAnalysis( P: program )
{
	ModuleDecl: module_decl = module_decl in P
	if ModuleDecl
		ModuleName = ModuleDecl.id
	
	for ThreadDef: thread_def in P {
		Thread: ptr<thread> = consThread( ThreadDef )[]
		ThreadMap.insert( $ThreadDef.id Thread )
	}

	for MessageDef: message_def in P {
		Message: ptr<message> = consMessage( MessageDef )[]
		MessageMap.insert( $MessageDef.id Message )
	}

	for StartsDecl: starts_decl in P {
		Owner: ptr<thread> = findThread( StartsDecl.Owner )
		Thread: ptr<thread> = findThread( StartsDecl.Thread )
		Owner->Starts.push_tail( Thread )
	}

	for SendsTo: sends_to_decl in P {
		Sender: ptr<thread> = findThread( SendsTo.Sender )
		Message: ptr<message> = findMessage( SendsTo.Message )
		Receiver: ptr<thread> = findThread( SendsTo.Receiver )

		# Record the sender->receiver relationship
		Sends: ptr<sends> = Sender->SendsMap.find( Receiver )
		if ( !Sends ) {
			Sends = new cons sends( Sender Receiver cons message_list[] )[]
			Sender->SendsMap.insert( Receiver Sends )
		}
		Sends->MessageList.push_tail( Message )
		Receiver->RecvsList.push_tail( Message )
	}

	# Make the root kobj.
	RootKobj = new cons kobj( 'root' )[]
	RootKobj->ShowAttrs = cons attr_list[]
	RootKobj->StoreAttrs = cons attr_list[]

	# Find the root attributes
	match P [DefList: definition*]
	for Def: definition in repeat( DefList ) {
		if match Def [AD: attr_decl] {
			Attr: ptr<attr> = new cons attr( $AD.id )[]

			for Mod: attr_modifier in AD {
				if match Mod [`show]
					RootKobj->ShowAttrs.push_tail( Attr )
				elsif match Mod [`store]
					RootKobj->StoreAttrs.push_tail( Attr )
			}
		}
	}
}
