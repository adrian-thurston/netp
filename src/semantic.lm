
global ModuleName: id

global RootAttrs: attribute_decl* = cons attribute_decl*[]

void semanticAnalysis( P: program )
{
	ModuleDecl: module_decl = module_decl in P
	if ModuleDecl
		ModuleName = ModuleDecl.id
	
	for ThreadDef: thread_def in P {
		Thread: ptr<thread> = consThread( ThreadDef )[]
		ThreadMap.insert( $ThreadDef.id Thread )
	}

	for MessageDef: message_def in P {
		Message: ptr<message> = consMessage( MessageDef )[]
		MessageMap.insert( $MessageDef.id Message )
	}

	for StartsDecl: starts_decl in P {
		Owner: ptr<thread> = findThread( StartsDecl.Owner )
		Thread: ptr<thread> = findThread( StartsDecl.Thread )
		Owner->Starts.push_tail( Thread )
	}

	for SendsTo: sends_to_decl in P {
		Sender: ptr<thread> = findThread( SendsTo.Sender )
		Message: ptr<message> = findMessage( SendsTo.Message )
		Receiver: ptr<thread> = findThread( SendsTo.Receiver )

		# Record the sender->receiver relationship
		Sends: ptr<sends> = Sender->SendsMap.find( Receiver )
		if ( !Sends ) {
			Sends = new cons sends( Sender Receiver cons message_list[] )[]
			Sender->SendsMap.insert( Receiver Sends )
		}
		Sends->MessageList.push_tail( Message )
		Receiver->RecvsList.push_tail( Message )
	}

	# Find the root attributes
	match P [DefList: definition*]
	AL: attribute_decl* = cons attribute_decl*[]
	for Def: definition in repeat( DefList ) {
		if match Def [AD: attribute_decl] {
			# This should be an append, doesn't exist in colm.
			for L: attribute_decl* in AL {
				if match L [] {
					L = cons attribute_decl*[AD]
					break
				}
			}
		}
	}
	RootAttrs = AL
}
