
global ModuleName: id
global KobjList: kobj_list = cons kobj_list[]

global AttrNum: int = 1

void attrDecl( Kobj: ptr<kobj> AD: attr_decl )
{
	Attr: ptr<attr> = new cons attr( $AD.id )[]

	for Mod: attr_modifier in AD {
		if match Mod [`show]
			Attr->Show = true
		elsif match Mod [`store]
			Attr->Store = true
	}

	Attr->Num = AttrNum
	Kobj->Attrs.push_tail( Attr )

	AttrNum = AttrNum + 1
}

void semanticAnalysis( P: program )
{
	ModuleDecl: module_decl = module_decl in P
	if ModuleDecl
		ModuleName = ModuleDecl.id
	
	for ThreadDef: thread_def in P {
		Thread: ptr<thread> = consThread( ThreadDef )[]
		ThreadMap.insert( $ThreadDef.id Thread )
	}

	for MessageDef: message_def in P {
		Message: ptr<message> = consMessage( MessageDef )[]
		MessageMap.insert( $MessageDef.id Message )
	}

	for StartsDecl: starts_decl in P {
		Owner: ptr<thread> = findThread( StartsDecl.Owner )
		Thread: ptr<thread> = findThread( StartsDecl.Thread )
		Owner->Starts.push_tail( Thread )
	}

	for SendsTo: sends_to_decl in P {
		Sender: ptr<thread> = findThread( SendsTo.Sender )
		Message: ptr<message> = findMessage( SendsTo.Message )
		Receiver: ptr<thread> = findThread( SendsTo.Receiver )

		# Record the sender->receiver relationship
		Sends: ptr<sends> = Sender->SendsMap.find( Receiver )
		if ( !Sends ) {
			Sends = new cons sends( Sender Receiver cons message_list[] )[]
			Sender->SendsMap.insert( Receiver Sends )
		}
		Sends->MessageList.push_tail( Message )
		Receiver->RecvsList.push_tail( Message )
	}

	# Make the root kobj.
	RootKobj: ptr<kobj> = new cons kobj( $ModuleName )[]
	RootKobj->Attrs = cons attr_list[]
	KobjList.push_tail( RootKobj )

	# Find the root attributes
	match P [DefList: definition*]
	for Def: definition in repeat( DefList ) {
		if match Def [AD: attr_decl]
			attrDecl( RootKobj AD )
	}

	for KD: kobj_def in P {
		Kobj: ptr<kobj> = new cons kobj( $KD.id )[]
		Kobj->Attrs = cons attr_list[]
		for AD: attr_decl in KD 
			attrDecl( Kobj AD )
		KobjList.push_tail( Kobj )
	}
}
